--- Contenido de add-functions.txt ---
Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Add keyword
Add answer
Add Action
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Add keyword
addKeyword
is the starting point of a conversation flow, just need to pass an
array of keywords
,
when someone text those keywords in the chatbot, the function will trigger the predefined dialog you have set up.
In the following example is stablished a conversation flow that received the keywords 'hello' and 'hi',
then the chatbot will send a message using
addAnswer
with the text 'Hi, welcome to my amazing shop, how can I help you?'
and 'The shop offers: shoes, shirts, pants, and hats'.
The addKeywords function also has a number of proprieties that will help you solve different use cases.
Some of these functions are:
regex
,
sensitive
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
([
'Hi, welcome to my amazing shop'
,
'how can I help you?'
])
.addAnswer
([
'The shop has: '
,
'shoes, shirts, pants, and hats'
])
Copy
Copied!
The conversation flow can be limited to a specific
keyword
, in example the word 'purchase' to trigger the next dialog
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
)
.addAnswer
([
'Great! '
,
'What do you want to buy?'
])
Copy
Copied!
addKeyword
Regex
The chatbot supports regex validation, in the following example an object is passed as the second parameter to the addKeyword function, the object has a property regex set to true and the keywords property is a regex pattern.
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
REGEX_GMAIL_EMAIL
=
/(\w
+
)@gmail\.com/
g
;
const
mainFlow
=
addKeyword
(
REGEX_GMAIL_EMAIL
,
{ regex
:
true
})
.addAnswer
(
`Thanks for the gmail address`
)
Copy
Copied!
addKeyword
Sensitive
The chatbot detects an specific keyword in any part of a message, but passing the
sensitive
property as
true
the chatbot will trigger the dialog if the user write down the exact same
keyword
.
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
,
{ sensitive
:
true
})
.addAnswer
([
'Great! '
,
'What do you want to buy?'
])
Copy
Copied!
Add answer
addAnswer
is used to send a message to the user, it can be a simple text or a file attached.
In the following example is stablished a conversation flow that received the keyword 'hello',
then the chatbot will send a message using
addAnswer
with the text
'Hi, welcome to my amazing shop, how can I help you?'
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi, welcome to my amazing shop, how can I help you?'
)
Copy
Copied!
There are different settings for sending messages, some functions such as sending files, images, video, delays, line breaks:
line breaks
,
consecutive
,
delay
,
callback
addAnswer
Consecutive Messages
The chatbot can send multiple messages just adding the addAnswer function one after another. In the following example the chatbot will send (3) messages:
Hi
,
Welcome to my amazing shop
,
how can I help you?
in that order.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi'
)
.addAnswer
(
'Welcome to my amazing shop'
)
.addAnswer
(
'how can I help you?'
)
Copy
Copied!
addAnswer
Message with line breaks
Whenever you need to send a message with line breaks, you can use an array of string as you can see in the following example.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
([
'Hi'
,
'Welcome to my amazing shop'
,
'how can I help you?'
])
Copy
Copied!
addAnswer
Message with delay
The chatbot can send a message with a
delay
, just add the addAnswer function with the delay property set to the amount of milliseconds you want to wait before sending the message.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'This message will after 2 seconds'
,
{ delay
:
2000
}
)
Copy
Copied!
Message with callback
When using callback functions in an addAnswers the operation prioritizes the sending of the message and then the execution of the function.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi!, Do you know 4+4?'
,
null
,
async
(_
,
{flowDynamic})
=>
{
const
sum
=
4
+
4
await
flowDynamic
(
`Total:
${
sum
}
`
)
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
await
flowDynamic
(
`Other message`
)
})
Copy
Copied!
Add Action
addAction
is used to define specific actions as a response when a whatsapp message has been received,
this function allows to trigger conversation flows based on the user's input and define how the chatbot should act.
In the folowing example you can see how you can trigger a function when the user sends a message with the keyword 'buy'.
app.ts
app.js
import
{ addKeyword
,
addAction }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
)
.addAnswer
(
'Great! What do you want to buy?'
)
.addAction
(
async
(_
,
{ flowDynamic })
:
void
=>
{
return
console
.log
(
'The user wants to buy something'
);
})
Copy
Copied!
You can use the
addAction
function with
capture
as you can see in the example below
app.ts
app.js
import
{ addKeyword
,
addAction }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
([
'Hello'
,
'Hi'
])
.addAction
(
async
(_
,
{ flowDynamic })
:
void
=>
{
return
flowDynamic
(
'Hi! how can I help you?'
);
})
.addAction
({ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
:
void
=>
{
await
state
.udpate
({ name
:
ctx
.body})
return
console
.flowDynamic
(
`The user said:
${
ctx
.body
}
`
);
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de concepts.txt ---
Why BuilderBot? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Flow
Provider
Database
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Why BuilderBot?
BuilderBot is the framework
for the creation of ChatBots focused on low-frequency communication channels, whatsapp, telegram, etc.
We implement an architecture focused on improving the developer experience and the reuse of logic at all times,
if you need to create chatbots for whatsapp quickly, without limits and easy connection between different providers then BuilderBot is for you.
The library is based on three key components for its correct functioning: the Flow, in charge of building the context of the conversation and offering a friendly interface to the developer; the Provider, which acts as a connector allowing to easily switch between WhatsApp providers without the risk of affecting other parts of the bot; and the Database, which in line with this connector philosophy, facilitates changing the data persistence layer without the need to rewrite the workflow.
Flow
Refers to creating structured sequences of interactions, as in building conversation flows. Two key methods are addKeyword and addAnswer, which allow keywords to be associated with specific responses, providing options for customizing the conversation flow.
Keywords are the words you will use to start the flow, you can use a single word or a list of words. Example "hello", "good morning".
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
Copy
Copied!
Some examples of how to use the addKeyword in which you can place the
keyword
or a list of
keywords
that will be used to start a conversational flow
// Example with single keyword
addKeyword
(
'hello'
)
.addAnswer
(
'Ey! welcome'
)
// Example with multi keywords
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
Copy
Copied!
For a quick understanding of the operation we have prepared a basic example of how to implement
View more examples
Provider
It is a key piece used to deliver the message to the chosen supplier. In a case you are building a bot for whatsapp you should use an adapter like
Meta
,
Twilio
,
Baileys
, etc or even if you want to connect to Telegram.
app.ts
provider.wppconnect.ts
provider.meta.ts
import
{ addKeyword
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
// ...stuff code...
const
main
=
async
()
=>
{
await
createBot
({
database
:
new
MemoryDB
()
,
provider
:
createProvider
(BaileysProvider)
,
flow
:
createFlow
([flowDemo])
})
}
main
()
Copy
Copied!
More information about the providers
Database
Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations.
It is ready to implement adapters from
Mongo
,
MySQL
,
Postgres
, among others.
app.ts
provider.wppconnect.ts
provider.meta.ts
import
{ addKeyword
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
// ...stuff code...
const
main
=
async
()
=>
{
await
createBot
({
database
:
new
MemoryDB
()
,
provider
:
createProvider
(BaileysProvider)
,
flow
:
createFlow
([flowDemo])
})
}
main
()
Copy
Copied!
More information about the databases
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de context.txt ---
Context - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Context
The "context" object is a key component within the framework that provides developers with access to essential information about the ongoing interaction between the user and the bot. This information includes default properties like
from
(representing the sender) and
body
(containing the message or input from the user).
When utilizing the framework's
addAnswer
and
addAction
methods, the context object is passed as the first argument in the callback functions. This allows developers to access and manipulate the context's properties dynamically, enabling tailored responses and actions based on the specifics of each user interaction.
flow-addKeyword.ts
flow-addAction.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowA
=
addKeyword
(
'register'
)
.addAnswer
(
'What is your name?'
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
const
responseName
=
ctx
.body
const
nameFrom
=
ctx
.name
const
numberFrom
=
ctx
.from
console
.log
(
`Other properties:`
,
ctx)
})
export
default
flowA
Copy
Copied!
It is important to note that the properties you will always have available are from, body, name but you will also have many more different properties depending on the
provider
.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de contribute.txt ---
Contribute - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Quick View
Why Contribute?
How to Contribute
GitHub Workflow
Writing MDX
VSCode
Extensions
Review Process
File Structure
Required Fields
Code Blocks
Language and Filename
Grouped code blocks
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Contribute
Welcome to the
BuilderBot
Contribution Guide We're glad to have you here.
This page provides instructions on how to edit BuilderBot documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our documentation.
Quick View
Make a fork of the
project
Clone the project
git clone https://github.com/USERNAME/documentation
Install dependencies
npm install
Make your changes
Send your contributions (PullRequest)
Why Contribute?
Open source work never ends, and neither does documentation. Contributing to the documentation is a great way for beginners to get involved in open source and for experienced developers to clarify more complex issues while sharing their knowledge with the community.
By contributing to BuilderBot documentation, you help us create a more robust learning resource for all developers. If you've found a typo, a confusing section, or noticed that a particular topic is missing, your contributions are welcome and appreciated.
How to Contribute
The content of the documentation is located in the
BuilderBot repository
. To contribute, you can edit the files directly on GitHub or clone the repository and edit the files locally.
GitHub Workflow
If you're new to GitHub, we recommend you read the GitHub Open Source Guide to learn how to fork a repository, create a branch, and send a pull request.
The code in the underlying documents lives in a private codebase that syncs with the public BuilderBot repository. This means that you cannot preview the docs locally. However, you will see your changes in builderbot.app after merging a pull request.
Writing MDX
The docs are written in
MDX
, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See the
GitHub Markdown Guide
for a quick overview of markdown syntax.
VSCode
Previewing Changes Locally
VSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.
Open the command palette (
⌘ + ⇧ + P
on Mac or
Ctrl + Shift + P
on Windows) and search from
Preferences: Open User Settings (JSON)
.
Then, add the following line to your
settings.json
file:
{
"files.associations"
:
{
"*.mdx"
:
"markdown"
}
}
Copy
Copied!
Next, open the command palette again, and search for
Markdown: Preview File
or
Markdown: Open Preview to the Side
. This will open a preview window where you can see your formatted changes.
Extensions
We also recommend the following extensions for VSCode users:
MDX
: Intellisense and syntax highlighting for MDX.
Grammarly
: Grammar and spell checker.
Prettier
: Format MDX files on save.
Review Process
Once you have submitted your contribution, a
Core Team
member will review your changes, provide feedback and merge the pull request when ready.
Please let us know if you have any questions or need further assistance in the comments of your PR. Thank you for contributing to the BuilderBot docs and for being part of our community.
File Structure
Documents use file system routing. Each folder and file within
/pages
represents a path segment. These segments are used to generate URL paths, navigation and breadcrumbs.
en
├── showcases
│   └── api-use.mdx
└── ...
Copy
Copied!
Each folder prefix
en
,
es
,
pt
represents the language in which the content is represented.
en
├── showcases
│   └── api-use.mdx
└── ...
es
├── showcases
│   └── api-use.mdx
└── ...
pt
├── showcases
│   └── api-use.mdx
└── ...
Copy
Copied!
Required Fields
The following fields are
required
:
Field
Description
description
The page's description, used in the
<meta name="description">
tag for SEO.
title
The page's
<h1>
title, used for SEO and OG Images.
export
const
description
=
'In this guide, we will talk ...'
# Community
Copy
Copied!
Code Blocks
The code blocks must contain a minimal working example that can be copied and pasted. This means that the code must be able to run without any additional configuration.
For example if we want to print TS or JS code
example.ts
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
}
Copy
Copied!
Always run examples locally before committing them. This will ensure that the code is up-to-date and working.
Language and Filename
Code blocks should have a header that includes the language and the
filename
. Add a
filename
prop to render a special Terminal icon that helps orientate users where to input the command. For example:
```
ts
{{ title: 'example.ts' }}
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
}
```
Copy
Copied!
Most examples in the docs are written in
tsx
and
jsx
, and a few in
bash
. However, you can use any supported language, here's the
full list
.
When writing JavaScript code blocks, we use the following language and extension combinations.
Language
Extension
JavaScript files
```js
.js
TypeScript files
```ts
.ts
Grouped code blocks
Sometimes we will need to represent a group of blocks of code grouped together even with different file names and in multiple languages we can do it in the following way
app.ts
provider/index.ts
database/index.ts
flow/index.ts
flow/welcome.flow.ts
services/ai.ts
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
Copy
Copied!
The template already provides internally a
<CodeGroup>
component that has the ability to interpret code blocks.
<
CodeGroup
>
```
ts
{{ title: 'app.ts' }}
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
```
```
ts
{{ title: 'provider/index.ts' }}
import
{ createProvider }
from
'@builderbot/bot'
;
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
;
export
const
provider
=
createProvider
(BaileysProvider)
```
```
ts
{{ title: 'database/index.ts' }}
export
const
database
=
new
MemoryDB
()
```
```
ts
{{ title: 'flow/index.ts' }}
import
{ createFlow }
from
'@builderbot/bot'
;
import
{ flowWelcome }
from
"./welcome.flow"
;
import
{ byeFlow }
from
"./bye.flow"
;
import
{ mediaFlow }
from
"./media.flow"
;
// other flows....
export
const
flow
=
createFlow
([flowWelcome
,
byeFlow
,
mediaFlow])
```
```
ts
{{ title: 'flow/welcome.flow.ts' }}
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
;
export
const
flowWelcome
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx
,
{flowDynamic
,
extensions})
=>
{
const
{
ai
}
=
extensions
const
talkWithGPT
=
ai
.chat
(
ctx
.body)
// Dependency AI from app.ts
await
flowDynamic
(talkWithGPT)
})
```
```
ts
{{ title: 'services/ai.ts' }}
// ....
export
const
ai
=
new
AiService
(
process
.
env
.
OPEN_AI_KEY
);
```
</
CodeGroup
>
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de contribute_core.txt ---
Core - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Core
https://www.youtube.com/watch?v=PzuE18-j9sY
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de databases.txt ---
Databases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Memory
Json
Mongo
MySQL
Postgres
Custom Database
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Databases
Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works.
The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations.
Many people use it as a chat history (in fact, it can also be used for that purpose), but you may find strange data in your logs because it stores not only messages, but also events.
Connectors:
MemoryDB
,
Json
,
Mongo
,
MySQL
,
Postgres
,
Custom Database
Each database may need to adjust the access keys, configuration, among other properties that will be implemented as configuration of the implemented class.
memory-database.ts
json-database.ts
mongo-database.ts
mysql-database.ts
postgres-database.ts
import
{ MemoryDB }
from
"@builderbot/bot"
;
export
type
IDatabase
=
typeof
MemoryDB
export
const
adapterDB
=
new
MemoryDB
();
Copy
Copied!
Below you will find more information about each of these databases.
Memory
The Memory database, often called a Mock database, operates without storing bot-generated responses and needs no configuration. Primarily used for testing and development, it offers a lightweight and convenient solution. This database type is ideal for scenarios where data persistence isn't necessary, facilitating quick prototyping and efficient debugging without managing persistent data storage overhead.
memory-database.ts
app.ts
import
{ MemoryDB }
from
"@builderbot/bot"
;
export
type
IDatabase
=
typeof
MemoryDB
export
const
adapterDB
=
new
MemoryDB
();
Copy
Copied!
Json
JSON
database provides the benefit of securely storing bot-generated responses in a local file, ensuring durability across sessions. Utilizing this database type requires specifying a file path (
filename
) where the JSON data will be stored. It proves particularly valuable when preserving conversation history or user interactions is imperative.
By enabling structured data storage, it simplifies data retrieval and analysis, rendering it appropriate for applications where data persistence and retrieval play a critical role.
json-database.ts
app.ts
import
{ JsonFileDB }
from
'@builderbot/database-json'
;
export
type
IDatabase
=
typeof
JsonFileDB
export
const
adapterDB
=
new
JsonFileDB
({ filename
:
'db.json'
});
Copy
Copied!
Mongo
MongoDB
strength lies in its flexible document-oriented structure, which requires configuration parameters like the database URI and name (
dbUri
,
dbName
). Its scalable architecture provides robust storage capabilities, ideal for handling large data volumes.
By embracing a NoSQL approach, MongoDB offers flexibility in schema design, effortlessly accommodating evolving application needs. It proves particularly suitable for environments requiring high-performance data storage and retrieval, thanks to its efficient indexing and querying functionalities.
mongo-database.ts
app.ts
import
{ MongoDB }
from
'@builderbot/database-mongo'
export
type
IDatabase
=
typeof
MongoDB
export
const
adapterDB
=
new
MongoDB
({
dbUri
:
MONGO_DB_URI
,
dbName
:
MONGO_DB_NAME
,
})
Copy
Copied!
MySQL
MySQL
database, a widely embraced relational database management system, provides strong data storage capabilities for storing bot-generated responses. When integrating with MySQL, essential parameters such as
host
,
user
,
password
, and the
database
name must be specified. This database variant assures data durability and scalability, rendering it well-suited for applications demanding high-performance data storage and retrieval.
With MySQL, developers can harness advanced querying features and transaction support, facilitating efficient management of bot-generated data within a structured and secure framework.
mysql-database.ts
app.ts
import
{ MysqlDB }
from
'@builderbot/database-mysql'
export
type
IDatabase
=
typeof
MysqlDB
export
const
adapterDB
=
new
MysqlDB
({
host
:
MYSQL_DB_HOST
,
user
:
MYSQL_DB_USER
,
database
:
MYSQL_DB_NAME
,
password
:
MYSQL_DB_PASSWORD
,
})
Copy
Copied!
Postgres
PostgreSQL
database, celebrated for its reliability and cutting-edge features, presents formidable data storage solutions for bot-generated responses. Seamless integration with PostgreSQL entails specifying vital parameters such as
host
,
user
,
password
,
database
name, and
port
. This database variant guarantees data integrity and scalability, rendering it optimal for applications requiring top-tier data storage and retrieval performance.
Uses Cases
If you want connect your bot to cloud database like Supabase or any CloudProvider you can use it.
More info about Postgres connection uses cases
PostgreSQL's flexible architecture and endorsement of advanced data types empower developers to craft sophisticated bots endowed with extensive functionality. Leveraging PostgreSQL equips developers with potent querying capabilities, transactional support, and comprehensive data management features, fostering the creation of resilient and efficient bot systems.
postgres-database.ts
app.ts
import
{ PostgreSQLDB }
from
'@builderbot/database-postgres'
export
type
IDatabase
=
typeof
PostgreSQLDB
export
const
adapterDB
=
new
PostgreSQLDB
({
host
:
POSTGRES_DB_HOST
,
user
:
POSTGRES_DB_USER
,
database
:
POSTGRES_DB_NAME
,
password
:
POSTGRES_DB_PASSWORD
,
port
:
+
POSTGRES_DB_PORT
,
})
Copy
Copied!
Firebase Database Adapter
Custom Database
Custom database connector there is the possibility to build your own customized adapter,
we know that there are many more database providers that can be very useful, an example can be
Firebase Console
which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize your data.
app.ts
database/firebase.ts
database/types.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ FirebaseAdapter }
from
'./database/firebase'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
FirebaseAdapter
>([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
FirebaseAdapter
({
databaseURL
:
'YOUR URL FIREBASE REALTIME DATABASE'
,
pathPrivateKeyJson
:
"YOUR PATH CREDENTIALS JSON FIREBASE"
})()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de databases_postgres_uses-cases.txt ---
Supabase Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Supabase Uses Cases
Connect to your Cloud Supabase database
More info about Supabase connection uses cases
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de databases_postgres_uses-cases_uses-cases-supabase.txt ---
Getting Starter - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Getting Starter
Postgres database supports other types of connections as in this case it is Supabase, let's take a quick tour on the Supabase platform to get our database credentials
The first thing is to create your account if you don't have one yet
Supabase
account.
Log in with your Github user
The second thing is to create an organization which is the one that allows you to create projects, this part is intuitive, create one then the other
The database will ask you for a strong key, copy it and save it in a safe place, you will need it later for the connection :)
Once we have our database ready, the next thing is to go to the project configuration section
when clicking on database we will see all our configuration, you must copy each one do not forget that the key is the same when creating the project
at the end you should be able to configure your database as follows
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de deploy.txt ---
Deploying - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploying
Congratulations the time has come to take your project to production and for your convenience there are several ways to achieve this from quite tenic options to other easier strategies.
It should be noted that for the application to function correctly, the execution must be kept alive, which means that a server running the application code must be maintained.
Therefore,
it is not recommended to use serverless
services.
Deployment methods:
Railway
,
Docker
,
VPS
Easy
Railway
Railway
provides infrastructure primitives with sane defaults to manage secrets, builds, and deploys. So you can start quickly and focus on your product.
Using this service, you won't have to worry about anything as it is capable of automatically reading the different packages necessary for your application to function correctly, in addition to providing you with a subdomain with HTTPS security.
Start a new project
More info about it
Medium
Docker
Dockerizing
the application is the best option if you are looking for a more personalized and scalable solution. It is also important to note that today most cloud providers support Docker containers and offer automated deployment processes.
Bot templates come with a default
Dockerfile
for basic operation. Keep in mind that depending on other libraries you use, this file may need to be adapted for proper functioning.
List of bots
More info about it
Hard
VPS
Should you be considering the deployment of your bot onto a private server (VPS), our comprehensive guide is tailored specifically for Ubuntu server environments. This meticulously crafted, step-by-step manual not only provides detailed instructions but also offers insightful guidance on the critical factors to consider throughout the deployment process. By following this guide, you can navigate the intricacies of VPS deployment with confidence, ensuring a smooth and successful integration of your bot into your desired hosting environment.
Run on Ubuntu VPS
More info about it
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de deploy_docker.txt ---
Deploy - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
Build Image
Run Container
Portainer
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploy
Previously, you need to have
Docker installed
on your server depending on the operating system, the processes change, you can find all the official information about docker at this link.
Depending on the provider you have chosen, you will need a specific Docker implementation, but don't worry, as it comes automatically implemented in a file called Dockerfile, you can also view the other Dockerfiles in the templates section.
Dockerfile,
Build Image
,
Run Container
,
Portainer
Dockerfile
# THIS IS THE BASE IMAGE FOR THE BOT
FROM
node:21-alpine3.18
as
builder
# Enable Corepack and prepare for PNPM installation to increase performance
RUN
corepack enable && corepack prepare pnpm@latest --activate
ENV
PNPM_HOME=/usr/local/bin
# Set the working directory
WORKDIR
/app
# Copy package.json and pnpm-lock.yaml files to the working directory
COPY
package*.json pnpm-lock.yaml ./
# Install dependencies using PNPM
COPY
. .
RUN
pnpm i
# Create a new stage for deployment
FROM
builder
as
deploy
# Copy only necessary files and directories for deployment
COPY
--from=builder /app/src ./src
COPY
--from=builder /app/package.json /app/pnpm-lock.yaml ./
RUN
pnpm install
CMD
[
"pnpm"
,
"start"
]
Copy
Copied!
Build Image
In this step, we are going to build the Docker image with all the settings of your project, remember that depending on the libraries you are using, you may need to modify the
Dockerfile
for it to function correctly.
Build Image
docker build . -t builderbot:latest
Copy
Copied!
You can see in your console that the image starts to build and the process logs are coming out, you must ensure that it ends with
naming to docker.io/library/builderbot:latest
=> [internal] load build definition from Dockerfile                                             0.4s
 => [internal] load metadata for docker.io/library/node:21-alpine3.18                            3.6s
 => ....................
 => => naming to docker.io/library/builderbot:latest
Copy
Copied!
Run Container
To run your containerized image by passing different environment variables depending on the configuration needed, you can do it in the following way.
Remember to release the corresponding ports in your server's firewall. Example 3008
Run Container Full
Run Container Quick
docker rm -f bot 2>/dev/null
docker run \
  --name "bot" \
  --env OPENAI_API_KEY="your_api_key_value" \
  --env PORT=3008 \
  -p 3008:3008/tcp \
  -v "$(pwd)/bot_sessions:/app/bot_sessions:rw" \
  --cap-add SYS_ADMIN \
  --restart always \
  builderbot:latest
Copy
Copied!
Command
Explanation
docker rm -f bot 2>/dev/null
Deletes any running container named "bot", if it exists. The
2>/dev/null
redirects any error message to nothing, meaning if the container doesn't exist, no error message will be displayed.
docker run -d
Starts a new Docker container in detached mode (in the background).
--name "bot"
Assigns the name "amazing-bot" to the container.
--env OPENAI_API_KEY="API"
Sets the environment variable
OPENAI_API_KEY
inside the container to the provided value, which should be a valid API key to access OpenAI.
--user $(id -u):$(id -g)
Specifies the user and group under which the process will run inside the container.
$(id -u)
gets the current user ID of the system and
$(id -g)
gets the current group ID.
-p 3008:3008/tcp
Publishes port 3008 of the container to port 3008 of the host, allowing traffic to be directed to the container's port.
-v $(pwd)/bot_sessions:/app/bot_sessions:rw
Mounts the host directory
/root/sessions/bot_sessions
to the container directory
/app/bot_sessions
with read-write permissions (
rw
).
--cap-add SYS_ADMIN
Grants the container the
SYS_ADMIN
capability, providing a broad set of system administration capabilities.
--restart always
Configures the container to restart automatically if it stops or encounters an error.
builderbot:latest
Specifies the Docker image to be used for creating and running the container. In this case,
builderbot:latest
is the image tag.
Portainer
If you are already familiar with docker and want to manage different bots mounted in containers a good OpenSource option is portainer.
Portainer
Community Edition is a user-friendly platform tailored for managing containerized applications across various environments like Docker, Swarm, Kubernetes, and ACI. With its straightforward deployment and intuitive interface, it simplifies the management of container resources such as images, volumes, and networks through a graphical interface or an API. Portainer operates within a single container, adaptable to both Linux and Windows environments.
List of bots
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de deploy_meta.txt ---
Deploying Your Chatbot with Meta API - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploying Your Chatbot with Meta API
This guide is designed for those who have already followed the official documentation at
Meta Provider
.
It assumes that developer accounts have been created and business and app verification has been completed.
Requirements
What a VPS is
How to create a simple website
How to use Docker and its Docker Compose plugin.
Adding a Phone Number
The phone number cannot be associated with any Whatsapp or Whatsapp Business account (once the phone number is added, it cannot be used in any Whatsapp app). Just follow the instructions to register the number.
Adding a Payment Method
Add a payment method from the first steps section to link it to your application.
Configuring Permanent Token
Go to
https://developers.facebook.com/apps/
and select "Business" in your app.
This will direct you to the business configuration. Once there, select System Users in the Users tab, then click the add button and create a user with the administrator role.
Once the user is created, select it and click the add asset button. In the window that opens, select Apps and select your app. In the permissions menu, select full control and save the changes.
Then press the Generate New Token button. A window will open where you should select your app, the token expiration time (set it to permanent), and check the permission options named "whatsapp_business_messaging" and "whatsapp_business_management". Finally, click generate token.
Meta does not store the token in the configuration panel, so you should store it in a safe place.
Next, select the Accounts tab and select Whatsapp Accounts. If you have done everything correctly in the previous steps, you will have your Whatsapp Business account with the name of the Business. Select the business and click "add people", add the previously created administrator user and give it full control.
Preparing Your App for Deployment
Once your Chatbot is ready, you should upload it to a repository on GitHub or GitLab. Remember to use
.gitignore
so that folders or files with large size or sensitive content are not uploaded.
.gitignore
node_modules
.env
dist/*
Copy
Copied!
It is recommended to use dotenv to handle Meta tokens securely.
Open your bot with VSCode (or your preferred editor) and configure the environment variables.
Installing dotenv
npm
install
dotenv
--save
Copy
Copied!
.env
JWT_TOKEN='token secret'
NUMBER_ID='id of your number'
VERIFY_TOKEN='random string'
Copy
Copied!
app.ts
import
'dotenv/config'
const
adapterProvider
=
createProvider
(Provider
,
{
jwtToken
:
process
.
env
.
JWT_TOKEN
,
numberId
:
process
.
env
.
NUMBER_ID
,
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
version
:
'v16.0'
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de deploy_railway.txt ---
Railway - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Railway
Railway
provides infrastructure primitives with sane defaults to manage secrets, builds, and deploys. So you can start quickly and focus on your product.
Using this service, you won't have to worry about anything as it is capable of automatically reading the different packages necessary for your application to function correctly, in addition to providing you with a subdomain with HTTPS security.
Railway Step by Step
The first thing we need to do is click on start a new project and follow the steps you will find below
Start a new project
Now with your Github account linked in railway, you will be able to see the list of all your projects available for deployment, select the one corresponding to builderbot
To begin, register and click on Start a new project
Depending on whether your project requires environment variables
.env
, you should select Add variables or simply click on Deploy Now.
Select the GitHub project
After clicking on deploy, you will find a screen similar to the following where we can see the construction and deployment process of your project. Depending on the number of packages you have installed, this process may take approximately
4 to 10 minutes
. If you see that this time has elapsed and it is still running, try refreshing the browser.
Deploying
In the settings section, you will find a section called "networking" which has the ability to generate a domain, click on this will generate a domain with an SSL certificate that will serve you to use as a webhook, API, or even a portal to scan the QR code.
HTTPS Domain
Now you have your project deployed on railway, you can repeat these steps for each bot you want to deploy.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de deploy_vps.txt ---
VPS (Virtual Private Server) - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Pre-requirements
Install
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
VPS (Virtual Private Server)
Prioritize initiating a connection to your server using SSH or via your chosen cloud provider's preferred method. This initial step is essential to start following this entire tutorial.
If you are using windows I recommend
git-scm
, otherwise if you are using Linux or Mac you already have git by default.
ssh
root@XX.XX.XX.XXX
-pXX
sudo
apt-get
update
&&
sudo
apt-get
upgrade
-y
Copy
Copied!
Pre-requirements
First you must download the
NodeJS installation
depending on your operating system but this guide focuses on Ubuntu 22.
It is important to run the following commands in order for the changes to take effect
Install NVM (Node Version Manager)
curl
-o-
https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh
|
bash
Copy
Copied!
Set NVM environment variables
export
NVM_DIR
=
"$HOME/.nvm"
[
-s
"$NVM_DIR/nvm.sh"
]
&&
\.
"$NVM_DIR/nvm.sh"
[
-s
"$NVM_DIR/bash_completion"
]
&&
\.
"$NVM_DIR/bash_completion"
Copy
Copied!
Install Node.js version 20
nvm
install
20
Copy
Copied!
Now you have node installed on your server ready to use, the following steps will be performed inside the directory of your project you are working on.
We will proceed to install
pnpm
the node package manager that we use and we will also install
pm2
that daemon which helps us to keep node applications running in the background.
Install pnpm and pm2
npm
i
pnpm@latest
pm2
--global
Copy
Copied!
Now we proceed to clone the builderbot-examples project and install the dependencies necessary for its operation.
Remember to release the corresponding ports in your server's firewall. Example 3008
Install
Clone Project
git
clone
https://github.com/codigoencasa/builderbot-examples-bot.git
cd
builderbot-examples-bot
Copy
Copied!
Install
/root/builderbot-examples-bot
pnpm
install
Copy
Copied!
Como es un proyecto en TypeScript necesitamos hacer el paso previo de la compilaciones y posteriormente iniciamos nuestro proyecto con pm2 ademas si quieres ver los logs puedes usar el comando
pm2 logs
Build
/root/builderbot-examples-bot
pnpm
run
build
pm2
start
./dist/app.js
--name
bot
pm2
logs
Copy
Copied!
Terminal
🛜  HTTP Server ON
[POST]: http://localhost:3008/v1/messages
[GET]: http://localhost:3008/

⚡⚡ ACTION REQUIRED ⚡⚡
You must scan the QR Code
Remember that the QR code updates every minute
Need help: https://link.codigoencasa.com/DISCORD
Copy
Copied!
As we can see the project is running and ready to scan the QR code, now only remains to link your whatsapp for that step visit
http://your-ip-public:3008
.
Remember this QR code is updated every 45 seconds approximately, if you have a linking error refresh the F5 page.
Link your whatsapp application
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en.txt ---
BuilderBot.app Create a WhatsApp Chatbot, Without Limit
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Get started with BuilderBot
This is a
free
and open source framework with an intuitive and extensible way to create chatbot and smart apps that connect to different communication channels like
Whatsapp
,
Telegram
and others.
We have made an intuitive framework so you can have your first chatbot in minutes.
Winner of the first prize at OpenExpo 2024
🏆
Quick Start
To create quickly with the following command
pnpm
npm
pnpm
create
builderbot@latest
Copy
Copied!
Installation and requirements
⚡ Building an AI bot
In this few minutes tutorial you can have your own chatbot with whatsapp and artificial intelligence to talk about your business.
Learn how to create a bot with the new open ai assistants
Code repository
Quick Example
In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are:
info, hello, hi
. You can see how to create the bot and implement the
flows
.
main.ts
main.js
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
3000
)
adapterProvider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_add-functions.txt ---
Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Add keyword
Add answer
Add Action
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Add keyword
addKeyword
is the starting point of a conversation flow, just need to pass an
array of keywords
,
when someone text those keywords in the chatbot, the function will trigger the predefined dialog you have set up.
In the following example is stablished a conversation flow that received the keywords 'hello' and 'hi',
then the chatbot will send a message using
addAnswer
with the text 'Hi, welcome to my amazing shop, how can I help you?'
and 'The shop offers: shoes, shirts, pants, and hats'.
The addKeywords function also has a number of proprieties that will help you solve different use cases.
Some of these functions are:
regex
,
sensitive
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
([
'Hi, welcome to my amazing shop'
,
'how can I help you?'
])
.addAnswer
([
'The shop has: '
,
'shoes, shirts, pants, and hats'
])
Copy
Copied!
The conversation flow can be limited to a specific
keyword
, in example the word 'purchase' to trigger the next dialog
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
)
.addAnswer
([
'Great! '
,
'What do you want to buy?'
])
Copy
Copied!
addKeyword
Regex
The chatbot supports regex validation, in the following example an object is passed as the second parameter to the addKeyword function, the object has a property regex set to true and the keywords property is a regex pattern.
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
REGEX_GMAIL_EMAIL
=
/(\w
+
)@gmail\.com/
g
;
const
mainFlow
=
addKeyword
(
REGEX_GMAIL_EMAIL
,
{ regex
:
true
})
.addAnswer
(
`Thanks for the gmail address`
)
Copy
Copied!
addKeyword
Sensitive
The chatbot detects an specific keyword in any part of a message, but passing the
sensitive
property as
true
the chatbot will trigger the dialog if the user write down the exact same
keyword
.
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
,
{ sensitive
:
true
})
.addAnswer
([
'Great! '
,
'What do you want to buy?'
])
Copy
Copied!
Add answer
addAnswer
is used to send a message to the user, it can be a simple text or a file attached.
In the following example is stablished a conversation flow that received the keyword 'hello',
then the chatbot will send a message using
addAnswer
with the text
'Hi, welcome to my amazing shop, how can I help you?'
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi, welcome to my amazing shop, how can I help you?'
)
Copy
Copied!
There are different settings for sending messages, some functions such as sending files, images, video, delays, line breaks:
line breaks
,
consecutive
,
delay
,
callback
addAnswer
Consecutive Messages
The chatbot can send multiple messages just adding the addAnswer function one after another. In the following example the chatbot will send (3) messages:
Hi
,
Welcome to my amazing shop
,
how can I help you?
in that order.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi'
)
.addAnswer
(
'Welcome to my amazing shop'
)
.addAnswer
(
'how can I help you?'
)
Copy
Copied!
addAnswer
Message with line breaks
Whenever you need to send a message with line breaks, you can use an array of string as you can see in the following example.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
([
'Hi'
,
'Welcome to my amazing shop'
,
'how can I help you?'
])
Copy
Copied!
addAnswer
Message with delay
The chatbot can send a message with a
delay
, just add the addAnswer function with the delay property set to the amount of milliseconds you want to wait before sending the message.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'This message will after 2 seconds'
,
{ delay
:
2000
}
)
Copy
Copied!
Message with callback
When using callback functions in an addAnswers the operation prioritizes the sending of the message and then the execution of the function.
app.ts
app.js
import
{ addKeyword
,
addAnswer }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'hello'
)
.addAnswer
(
'Hi!, Do you know 4+4?'
,
null
,
async
(_
,
{flowDynamic})
=>
{
const
sum
=
4
+
4
await
flowDynamic
(
`Total:
${
sum
}
`
)
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
await
flowDynamic
(
`Other message`
)
})
Copy
Copied!
Add Action
addAction
is used to define specific actions as a response when a whatsapp message has been received,
this function allows to trigger conversation flows based on the user's input and define how the chatbot should act.
In the folowing example you can see how you can trigger a function when the user sends a message with the keyword 'buy'.
app.ts
app.js
import
{ addKeyword
,
addAction }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
(
'buy'
)
.addAnswer
(
'Great! What do you want to buy?'
)
.addAction
(
async
(_
,
{ flowDynamic })
:
void
=>
{
return
console
.log
(
'The user wants to buy something'
);
})
Copy
Copied!
You can use the
addAction
function with
capture
as you can see in the example below
app.ts
app.js
import
{ addKeyword
,
addAction }
from
'@builderbot/bot'
;
const
mainFlow
=
addKeyword
([
'Hello'
,
'Hi'
])
.addAction
(
async
(_
,
{ flowDynamic })
:
void
=>
{
return
flowDynamic
(
'Hi! how can I help you?'
);
})
.addAction
({ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
:
void
=>
{
await
state
.udpate
({ name
:
ctx
.body})
return
console
.flowDynamic
(
`The user said:
${
ctx
.body
}
`
);
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_concepts.txt ---
Why BuilderBot? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Flow
Provider
Database
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Why BuilderBot?
BuilderBot is the framework
for the creation of ChatBots focused on low-frequency communication channels, whatsapp, telegram, etc.
We implement an architecture focused on improving the developer experience and the reuse of logic at all times,
if you need to create chatbots for whatsapp quickly, without limits and easy connection between different providers then BuilderBot is for you.
The library is based on three key components for its correct functioning: the Flow, in charge of building the context of the conversation and offering a friendly interface to the developer; the Provider, which acts as a connector allowing to easily switch between WhatsApp providers without the risk of affecting other parts of the bot; and the Database, which in line with this connector philosophy, facilitates changing the data persistence layer without the need to rewrite the workflow.
Flow
Refers to creating structured sequences of interactions, as in building conversation flows. Two key methods are addKeyword and addAnswer, which allow keywords to be associated with specific responses, providing options for customizing the conversation flow.
Keywords are the words you will use to start the flow, you can use a single word or a list of words. Example "hello", "good morning".
app.ts
app.js
import
{ addKeyword }
from
'@builderbot/bot'
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
Copy
Copied!
Some examples of how to use the addKeyword in which you can place the
keyword
or a list of
keywords
that will be used to start a conversational flow
// Example with single keyword
addKeyword
(
'hello'
)
.addAnswer
(
'Ey! welcome'
)
// Example with multi keywords
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
Copy
Copied!
For a quick understanding of the operation we have prepared a basic example of how to implement
View more examples
Provider
It is a key piece used to deliver the message to the chosen supplier. In a case you are building a bot for whatsapp you should use an adapter like
Meta
,
Twilio
,
Baileys
, etc or even if you want to connect to Telegram.
app.ts
provider.wppconnect.ts
provider.meta.ts
import
{ addKeyword
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
// ...stuff code...
const
main
=
async
()
=>
{
await
createBot
({
database
:
new
MemoryDB
()
,
provider
:
createProvider
(BaileysProvider)
,
flow
:
createFlow
([flowDemo])
})
}
main
()
Copy
Copied!
More information about the providers
Database
Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations.
It is ready to implement adapters from
Mongo
,
MySQL
,
Postgres
, among others.
app.ts
provider.wppconnect.ts
provider.meta.ts
import
{ addKeyword
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
// ...stuff code...
const
main
=
async
()
=>
{
await
createBot
({
database
:
new
MemoryDB
()
,
provider
:
createProvider
(BaileysProvider)
,
flow
:
createFlow
([flowDemo])
})
}
main
()
Copy
Copied!
More information about the databases
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_context.txt ---
Context - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Context
The "context" object is a key component within the framework that provides developers with access to essential information about the ongoing interaction between the user and the bot. This information includes default properties like
from
(representing the sender) and
body
(containing the message or input from the user).
When utilizing the framework's
addAnswer
and
addAction
methods, the context object is passed as the first argument in the callback functions. This allows developers to access and manipulate the context's properties dynamically, enabling tailored responses and actions based on the specifics of each user interaction.
flow-addKeyword.ts
flow-addAction.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowA
=
addKeyword
(
'register'
)
.addAnswer
(
'What is your name?'
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
const
responseName
=
ctx
.body
const
nameFrom
=
ctx
.name
const
numberFrom
=
ctx
.from
console
.log
(
`Other properties:`
,
ctx)
})
export
default
flowA
Copy
Copied!
It is important to note that the properties you will always have available are from, body, name but you will also have many more different properties depending on the
provider
.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_contribute.txt ---
Contribute - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Quick View
Why Contribute?
How to Contribute
GitHub Workflow
Writing MDX
VSCode
Extensions
Review Process
File Structure
Required Fields
Code Blocks
Language and Filename
Grouped code blocks
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Contribute
Welcome to the
BuilderBot
Contribution Guide We're glad to have you here.
This page provides instructions on how to edit BuilderBot documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our documentation.
Quick View
Make a fork of the
project
Clone the project
git clone https://github.com/USERNAME/documentation
Install dependencies
npm install
Make your changes
Send your contributions (PullRequest)
Why Contribute?
Open source work never ends, and neither does documentation. Contributing to the documentation is a great way for beginners to get involved in open source and for experienced developers to clarify more complex issues while sharing their knowledge with the community.
By contributing to BuilderBot documentation, you help us create a more robust learning resource for all developers. If you've found a typo, a confusing section, or noticed that a particular topic is missing, your contributions are welcome and appreciated.
How to Contribute
The content of the documentation is located in the
BuilderBot repository
. To contribute, you can edit the files directly on GitHub or clone the repository and edit the files locally.
GitHub Workflow
If you're new to GitHub, we recommend you read the GitHub Open Source Guide to learn how to fork a repository, create a branch, and send a pull request.
The code in the underlying documents lives in a private codebase that syncs with the public BuilderBot repository. This means that you cannot preview the docs locally. However, you will see your changes in builderbot.app after merging a pull request.
Writing MDX
The docs are written in
MDX
, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See the
GitHub Markdown Guide
for a quick overview of markdown syntax.
VSCode
Previewing Changes Locally
VSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.
Open the command palette (
⌘ + ⇧ + P
on Mac or
Ctrl + Shift + P
on Windows) and search from
Preferences: Open User Settings (JSON)
.
Then, add the following line to your
settings.json
file:
{
"files.associations"
:
{
"*.mdx"
:
"markdown"
}
}
Copy
Copied!
Next, open the command palette again, and search for
Markdown: Preview File
or
Markdown: Open Preview to the Side
. This will open a preview window where you can see your formatted changes.
Extensions
We also recommend the following extensions for VSCode users:
MDX
: Intellisense and syntax highlighting for MDX.
Grammarly
: Grammar and spell checker.
Prettier
: Format MDX files on save.
Review Process
Once you have submitted your contribution, a
Core Team
member will review your changes, provide feedback and merge the pull request when ready.
Please let us know if you have any questions or need further assistance in the comments of your PR. Thank you for contributing to the BuilderBot docs and for being part of our community.
File Structure
Documents use file system routing. Each folder and file within
/pages
represents a path segment. These segments are used to generate URL paths, navigation and breadcrumbs.
en
├── showcases
│   └── api-use.mdx
└── ...
Copy
Copied!
Each folder prefix
en
,
es
,
pt
represents the language in which the content is represented.
en
├── showcases
│   └── api-use.mdx
└── ...
es
├── showcases
│   └── api-use.mdx
└── ...
pt
├── showcases
│   └── api-use.mdx
└── ...
Copy
Copied!
Required Fields
The following fields are
required
:
Field
Description
description
The page's description, used in the
<meta name="description">
tag for SEO.
title
The page's
<h1>
title, used for SEO and OG Images.
export
const
description
=
'In this guide, we will talk ...'
# Community
Copy
Copied!
Code Blocks
The code blocks must contain a minimal working example that can be copied and pasted. This means that the code must be able to run without any additional configuration.
For example if we want to print TS or JS code
example.ts
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
}
Copy
Copied!
Always run examples locally before committing them. This will ensure that the code is up-to-date and working.
Language and Filename
Code blocks should have a header that includes the language and the
filename
. Add a
filename
prop to render a special Terminal icon that helps orientate users where to input the command. For example:
```
ts
{{ title: 'example.ts' }}
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
}
```
Copy
Copied!
Most examples in the docs are written in
tsx
and
jsx
, and a few in
bash
. However, you can use any supported language, here's the
full list
.
When writing JavaScript code blocks, we use the following language and extension combinations.
Language
Extension
JavaScript files
```js
.js
TypeScript files
```ts
.ts
Grouped code blocks
Sometimes we will need to represent a group of blocks of code grouped together even with different file names and in multiple languages we can do it in the following way
app.ts
provider/index.ts
database/index.ts
flow/index.ts
flow/welcome.flow.ts
services/ai.ts
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
Copy
Copied!
The template already provides internally a
<CodeGroup>
component that has the ability to interpret code blocks.
<
CodeGroup
>
```
ts
{{ title: 'app.ts' }}
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
```
```
ts
{{ title: 'provider/index.ts' }}
import
{ createProvider }
from
'@builderbot/bot'
;
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
;
export
const
provider
=
createProvider
(BaileysProvider)
```
```
ts
{{ title: 'database/index.ts' }}
export
const
database
=
new
MemoryDB
()
```
```
ts
{{ title: 'flow/index.ts' }}
import
{ createFlow }
from
'@builderbot/bot'
;
import
{ flowWelcome }
from
"./welcome.flow"
;
import
{ byeFlow }
from
"./bye.flow"
;
import
{ mediaFlow }
from
"./media.flow"
;
// other flows....
export
const
flow
=
createFlow
([flowWelcome
,
byeFlow
,
mediaFlow])
```
```
ts
{{ title: 'flow/welcome.flow.ts' }}
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
;
export
const
flowWelcome
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx
,
{flowDynamic
,
extensions})
=>
{
const
{
ai
}
=
extensions
const
talkWithGPT
=
ai
.chat
(
ctx
.body)
// Dependency AI from app.ts
await
flowDynamic
(talkWithGPT)
})
```
```
ts
{{ title: 'services/ai.ts' }}
// ....
export
const
ai
=
new
AiService
(
process
.
env
.
OPEN_AI_KEY
);
```
</
CodeGroup
>
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_contribute_core.txt ---
Core - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Core
https://www.youtube.com/watch?v=PzuE18-j9sY
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_databases.txt ---
Databases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Memory
Json
Mongo
MySQL
Postgres
Custom Database
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Databases
Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works.
The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations.
Many people use it as a chat history (in fact, it can also be used for that purpose), but you may find strange data in your logs because it stores not only messages, but also events.
Connectors:
MemoryDB
,
Json
,
Mongo
,
MySQL
,
Postgres
,
Custom Database
Each database may need to adjust the access keys, configuration, among other properties that will be implemented as configuration of the implemented class.
memory-database.ts
json-database.ts
mongo-database.ts
mysql-database.ts
postgres-database.ts
import
{ MemoryDB }
from
"@builderbot/bot"
;
export
type
IDatabase
=
typeof
MemoryDB
export
const
adapterDB
=
new
MemoryDB
();
Copy
Copied!
Below you will find more information about each of these databases.
Memory
The Memory database, often called a Mock database, operates without storing bot-generated responses and needs no configuration. Primarily used for testing and development, it offers a lightweight and convenient solution. This database type is ideal for scenarios where data persistence isn't necessary, facilitating quick prototyping and efficient debugging without managing persistent data storage overhead.
memory-database.ts
app.ts
import
{ MemoryDB }
from
"@builderbot/bot"
;
export
type
IDatabase
=
typeof
MemoryDB
export
const
adapterDB
=
new
MemoryDB
();
Copy
Copied!
Json
JSON
database provides the benefit of securely storing bot-generated responses in a local file, ensuring durability across sessions. Utilizing this database type requires specifying a file path (
filename
) where the JSON data will be stored. It proves particularly valuable when preserving conversation history or user interactions is imperative.
By enabling structured data storage, it simplifies data retrieval and analysis, rendering it appropriate for applications where data persistence and retrieval play a critical role.
json-database.ts
app.ts
import
{ JsonFileDB }
from
'@builderbot/database-json'
;
export
type
IDatabase
=
typeof
JsonFileDB
export
const
adapterDB
=
new
JsonFileDB
({ filename
:
'db.json'
});
Copy
Copied!
Mongo
MongoDB
strength lies in its flexible document-oriented structure, which requires configuration parameters like the database URI and name (
dbUri
,
dbName
). Its scalable architecture provides robust storage capabilities, ideal for handling large data volumes.
By embracing a NoSQL approach, MongoDB offers flexibility in schema design, effortlessly accommodating evolving application needs. It proves particularly suitable for environments requiring high-performance data storage and retrieval, thanks to its efficient indexing and querying functionalities.
mongo-database.ts
app.ts
import
{ MongoDB }
from
'@builderbot/database-mongo'
export
type
IDatabase
=
typeof
MongoDB
export
const
adapterDB
=
new
MongoDB
({
dbUri
:
MONGO_DB_URI
,
dbName
:
MONGO_DB_NAME
,
})
Copy
Copied!
MySQL
MySQL
database, a widely embraced relational database management system, provides strong data storage capabilities for storing bot-generated responses. When integrating with MySQL, essential parameters such as
host
,
user
,
password
, and the
database
name must be specified. This database variant assures data durability and scalability, rendering it well-suited for applications demanding high-performance data storage and retrieval.
With MySQL, developers can harness advanced querying features and transaction support, facilitating efficient management of bot-generated data within a structured and secure framework.
mysql-database.ts
app.ts
import
{ MysqlDB }
from
'@builderbot/database-mysql'
export
type
IDatabase
=
typeof
MysqlDB
export
const
adapterDB
=
new
MysqlDB
({
host
:
MYSQL_DB_HOST
,
user
:
MYSQL_DB_USER
,
database
:
MYSQL_DB_NAME
,
password
:
MYSQL_DB_PASSWORD
,
})
Copy
Copied!
Postgres
PostgreSQL
database, celebrated for its reliability and cutting-edge features, presents formidable data storage solutions for bot-generated responses. Seamless integration with PostgreSQL entails specifying vital parameters such as
host
,
user
,
password
,
database
name, and
port
. This database variant guarantees data integrity and scalability, rendering it optimal for applications requiring top-tier data storage and retrieval performance.
Uses Cases
If you want connect your bot to cloud database like Supabase or any CloudProvider you can use it.
More info about Postgres connection uses cases
PostgreSQL's flexible architecture and endorsement of advanced data types empower developers to craft sophisticated bots endowed with extensive functionality. Leveraging PostgreSQL equips developers with potent querying capabilities, transactional support, and comprehensive data management features, fostering the creation of resilient and efficient bot systems.
postgres-database.ts
app.ts
import
{ PostgreSQLDB }
from
'@builderbot/database-postgres'
export
type
IDatabase
=
typeof
PostgreSQLDB
export
const
adapterDB
=
new
PostgreSQLDB
({
host
:
POSTGRES_DB_HOST
,
user
:
POSTGRES_DB_USER
,
database
:
POSTGRES_DB_NAME
,
password
:
POSTGRES_DB_PASSWORD
,
port
:
+
POSTGRES_DB_PORT
,
})
Copy
Copied!
Firebase Database Adapter
Custom Database
Custom database connector there is the possibility to build your own customized adapter,
we know that there are many more database providers that can be very useful, an example can be
Firebase Console
which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize your data.
app.ts
database/firebase.ts
database/types.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ FirebaseAdapter }
from
'./database/firebase'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
FirebaseAdapter
>([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
FirebaseAdapter
({
databaseURL
:
'YOUR URL FIREBASE REALTIME DATABASE'
,
pathPrivateKeyJson
:
"YOUR PATH CREDENTIALS JSON FIREBASE"
})()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_databases_postgres_uses-cases.txt ---
Supabase Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Supabase Uses Cases
Connect to your Cloud Supabase database
More info about Supabase connection uses cases
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_databases_postgres_uses-cases_uses-cases-supabase.txt ---
Getting Starter - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Getting Starter
Postgres database supports other types of connections as in this case it is Supabase, let's take a quick tour on the Supabase platform to get our database credentials
The first thing is to create your account if you don't have one yet
Supabase
account.
Log in with your Github user
The second thing is to create an organization which is the one that allows you to create projects, this part is intuitive, create one then the other
The database will ask you for a strong key, copy it and save it in a safe place, you will need it later for the connection :)
Once we have our database ready, the next thing is to go to the project configuration section
when clicking on database we will see all our configuration, you must copy each one do not forget that the key is the same when creating the project
at the end you should be able to configure your database as follows
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_deploy.txt ---
Deploying - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploying
Congratulations the time has come to take your project to production and for your convenience there are several ways to achieve this from quite tenic options to other easier strategies.
It should be noted that for the application to function correctly, the execution must be kept alive, which means that a server running the application code must be maintained.
Therefore,
it is not recommended to use serverless
services.
Deployment methods:
Railway
,
Docker
,
VPS
Easy
Railway
Railway
provides infrastructure primitives with sane defaults to manage secrets, builds, and deploys. So you can start quickly and focus on your product.
Using this service, you won't have to worry about anything as it is capable of automatically reading the different packages necessary for your application to function correctly, in addition to providing you with a subdomain with HTTPS security.
Start a new project
More info about it
Medium
Docker
Dockerizing
the application is the best option if you are looking for a more personalized and scalable solution. It is also important to note that today most cloud providers support Docker containers and offer automated deployment processes.
Bot templates come with a default
Dockerfile
for basic operation. Keep in mind that depending on other libraries you use, this file may need to be adapted for proper functioning.
List of bots
More info about it
Hard
VPS
Should you be considering the deployment of your bot onto a private server (VPS), our comprehensive guide is tailored specifically for Ubuntu server environments. This meticulously crafted, step-by-step manual not only provides detailed instructions but also offers insightful guidance on the critical factors to consider throughout the deployment process. By following this guide, you can navigate the intricacies of VPS deployment with confidence, ensuring a smooth and successful integration of your bot into your desired hosting environment.
Run on Ubuntu VPS
More info about it
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_deploy_docker.txt ---
Deploy - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
Build Image
Run Container
Portainer
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploy
Previously, you need to have
Docker installed
on your server depending on the operating system, the processes change, you can find all the official information about docker at this link.
Depending on the provider you have chosen, you will need a specific Docker implementation, but don't worry, as it comes automatically implemented in a file called Dockerfile, you can also view the other Dockerfiles in the templates section.
Dockerfile,
Build Image
,
Run Container
,
Portainer
Dockerfile
# THIS IS THE BASE IMAGE FOR THE BOT
FROM
node:21-alpine3.18
as
builder
# Enable Corepack and prepare for PNPM installation to increase performance
RUN
corepack enable && corepack prepare pnpm@latest --activate
ENV
PNPM_HOME=/usr/local/bin
# Set the working directory
WORKDIR
/app
# Copy package.json and pnpm-lock.yaml files to the working directory
COPY
package*.json pnpm-lock.yaml ./
# Install dependencies using PNPM
COPY
. .
RUN
pnpm i
# Create a new stage for deployment
FROM
builder
as
deploy
# Copy only necessary files and directories for deployment
COPY
--from=builder /app/src ./src
COPY
--from=builder /app/package.json /app/pnpm-lock.yaml ./
RUN
pnpm install
CMD
[
"pnpm"
,
"start"
]
Copy
Copied!
Build Image
In this step, we are going to build the Docker image with all the settings of your project, remember that depending on the libraries you are using, you may need to modify the
Dockerfile
for it to function correctly.
Build Image
docker build . -t builderbot:latest
Copy
Copied!
You can see in your console that the image starts to build and the process logs are coming out, you must ensure that it ends with
naming to docker.io/library/builderbot:latest
=> [internal] load build definition from Dockerfile                                             0.4s
 => [internal] load metadata for docker.io/library/node:21-alpine3.18                            3.6s
 => ....................
 => => naming to docker.io/library/builderbot:latest
Copy
Copied!
Run Container
To run your containerized image by passing different environment variables depending on the configuration needed, you can do it in the following way.
Remember to release the corresponding ports in your server's firewall. Example 3008
Run Container Full
Run Container Quick
docker rm -f bot 2>/dev/null
docker run \
  --name "bot" \
  --env OPENAI_API_KEY="your_api_key_value" \
  --env PORT=3008 \
  -p 3008:3008/tcp \
  -v "$(pwd)/bot_sessions:/app/bot_sessions:rw" \
  --cap-add SYS_ADMIN \
  --restart always \
  builderbot:latest
Copy
Copied!
Command
Explanation
docker rm -f bot 2>/dev/null
Deletes any running container named "bot", if it exists. The
2>/dev/null
redirects any error message to nothing, meaning if the container doesn't exist, no error message will be displayed.
docker run -d
Starts a new Docker container in detached mode (in the background).
--name "bot"
Assigns the name "amazing-bot" to the container.
--env OPENAI_API_KEY="API"
Sets the environment variable
OPENAI_API_KEY
inside the container to the provided value, which should be a valid API key to access OpenAI.
--user $(id -u):$(id -g)
Specifies the user and group under which the process will run inside the container.
$(id -u)
gets the current user ID of the system and
$(id -g)
gets the current group ID.
-p 3008:3008/tcp
Publishes port 3008 of the container to port 3008 of the host, allowing traffic to be directed to the container's port.
-v $(pwd)/bot_sessions:/app/bot_sessions:rw
Mounts the host directory
/root/sessions/bot_sessions
to the container directory
/app/bot_sessions
with read-write permissions (
rw
).
--cap-add SYS_ADMIN
Grants the container the
SYS_ADMIN
capability, providing a broad set of system administration capabilities.
--restart always
Configures the container to restart automatically if it stops or encounters an error.
builderbot:latest
Specifies the Docker image to be used for creating and running the container. In this case,
builderbot:latest
is the image tag.
Portainer
If you are already familiar with docker and want to manage different bots mounted in containers a good OpenSource option is portainer.
Portainer
Community Edition is a user-friendly platform tailored for managing containerized applications across various environments like Docker, Swarm, Kubernetes, and ACI. With its straightforward deployment and intuitive interface, it simplifies the management of container resources such as images, volumes, and networks through a graphical interface or an API. Portainer operates within a single container, adaptable to both Linux and Windows environments.
List of bots
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_deploy_meta.txt ---
Deploying Your Chatbot with Meta API - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Deploying Your Chatbot with Meta API
This guide is designed for those who have already followed the official documentation at
Meta Provider
.
It assumes that developer accounts have been created and business and app verification has been completed.
Requirements
What a VPS is
How to create a simple website
How to use Docker and its Docker Compose plugin.
Adding a Phone Number
The phone number cannot be associated with any Whatsapp or Whatsapp Business account (once the phone number is added, it cannot be used in any Whatsapp app). Just follow the instructions to register the number.
Adding a Payment Method
Add a payment method from the first steps section to link it to your application.
Configuring Permanent Token
Go to
https://developers.facebook.com/apps/
and select "Business" in your app.
This will direct you to the business configuration. Once there, select System Users in the Users tab, then click the add button and create a user with the administrator role.
Once the user is created, select it and click the add asset button. In the window that opens, select Apps and select your app. In the permissions menu, select full control and save the changes.
Then press the Generate New Token button. A window will open where you should select your app, the token expiration time (set it to permanent), and check the permission options named "whatsapp_business_messaging" and "whatsapp_business_management". Finally, click generate token.
Meta does not store the token in the configuration panel, so you should store it in a safe place.
Next, select the Accounts tab and select Whatsapp Accounts. If you have done everything correctly in the previous steps, you will have your Whatsapp Business account with the name of the Business. Select the business and click "add people", add the previously created administrator user and give it full control.
Preparing Your App for Deployment
Once your Chatbot is ready, you should upload it to a repository on GitHub or GitLab. Remember to use
.gitignore
so that folders or files with large size or sensitive content are not uploaded.
.gitignore
node_modules
.env
dist/*
Copy
Copied!
It is recommended to use dotenv to handle Meta tokens securely.
Open your bot with VSCode (or your preferred editor) and configure the environment variables.
Installing dotenv
npm
install
dotenv
--save
Copy
Copied!
.env
JWT_TOKEN='token secret'
NUMBER_ID='id of your number'
VERIFY_TOKEN='random string'
Copy
Copied!
app.ts
import
'dotenv/config'
const
adapterProvider
=
createProvider
(Provider
,
{
jwtToken
:
process
.
env
.
JWT_TOKEN
,
numberId
:
process
.
env
.
NUMBER_ID
,
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
version
:
'v16.0'
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_deploy_railway.txt ---
Railway - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Railway
Railway
provides infrastructure primitives with sane defaults to manage secrets, builds, and deploys. So you can start quickly and focus on your product.
Using this service, you won't have to worry about anything as it is capable of automatically reading the different packages necessary for your application to function correctly, in addition to providing you with a subdomain with HTTPS security.
Railway Step by Step
The first thing we need to do is click on start a new project and follow the steps you will find below
Start a new project
Now with your Github account linked in railway, you will be able to see the list of all your projects available for deployment, select the one corresponding to builderbot
To begin, register and click on Start a new project
Depending on whether your project requires environment variables
.env
, you should select Add variables or simply click on Deploy Now.
Select the GitHub project
After clicking on deploy, you will find a screen similar to the following where we can see the construction and deployment process of your project. Depending on the number of packages you have installed, this process may take approximately
4 to 10 minutes
. If you see that this time has elapsed and it is still running, try refreshing the browser.
Deploying
In the settings section, you will find a section called "networking" which has the ability to generate a domain, click on this will generate a domain with an SSL certificate that will serve you to use as a webhook, API, or even a portal to scan the QR code.
HTTPS Domain
Now you have your project deployed on railway, you can repeat these steps for each bot you want to deploy.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_deploy_vps.txt ---
VPS (Virtual Private Server) - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Pre-requirements
Install
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
VPS (Virtual Private Server)
Prioritize initiating a connection to your server using SSH or via your chosen cloud provider's preferred method. This initial step is essential to start following this entire tutorial.
If you are using windows I recommend
git-scm
, otherwise if you are using Linux or Mac you already have git by default.
ssh
root@XX.XX.XX.XXX
-pXX
sudo
apt-get
update
&&
sudo
apt-get
upgrade
-y
Copy
Copied!
Pre-requirements
First you must download the
NodeJS installation
depending on your operating system but this guide focuses on Ubuntu 22.
It is important to run the following commands in order for the changes to take effect
Install NVM (Node Version Manager)
curl
-o-
https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh
|
bash
Copy
Copied!
Set NVM environment variables
export
NVM_DIR
=
"$HOME/.nvm"
[
-s
"$NVM_DIR/nvm.sh"
]
&&
\.
"$NVM_DIR/nvm.sh"
[
-s
"$NVM_DIR/bash_completion"
]
&&
\.
"$NVM_DIR/bash_completion"
Copy
Copied!
Install Node.js version 20
nvm
install
20
Copy
Copied!
Now you have node installed on your server ready to use, the following steps will be performed inside the directory of your project you are working on.
We will proceed to install
pnpm
the node package manager that we use and we will also install
pm2
that daemon which helps us to keep node applications running in the background.
Install pnpm and pm2
npm
i
pnpm@latest
pm2
--global
Copy
Copied!
Now we proceed to clone the builderbot-examples project and install the dependencies necessary for its operation.
Remember to release the corresponding ports in your server's firewall. Example 3008
Install
Clone Project
git
clone
https://github.com/codigoencasa/builderbot-examples-bot.git
cd
builderbot-examples-bot
Copy
Copied!
Install
/root/builderbot-examples-bot
pnpm
install
Copy
Copied!
Como es un proyecto en TypeScript necesitamos hacer el paso previo de la compilaciones y posteriormente iniciamos nuestro proyecto con pm2 ademas si quieres ver los logs puedes usar el comando
pm2 logs
Build
/root/builderbot-examples-bot
pnpm
run
build
pm2
start
./dist/app.js
--name
bot
pm2
logs
Copy
Copied!
Terminal
🛜  HTTP Server ON
[POST]: http://localhost:3008/v1/messages
[GET]: http://localhost:3008/

⚡⚡ ACTION REQUIRED ⚡⚡
You must scan the QR Code
Remember that the QR code updates every minute
Need help: https://link.codigoencasa.com/DISCORD
Copy
Copied!
As we can see the project is running and ready to scan the QR code, now only remains to link your whatsapp for that step visit
http://your-ip-public:3008
.
Remember this QR code is updated every 45 seconds approximately, if you have a linking error refresh the F5 page.
Link your whatsapp application
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_events.txt ---
Events - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Default
WELCOME
Received Image or Video
MEDIA
Received Document
DOCUMENT
Received Location
LOCATION
Received Voice Note
VOICE_NOTE
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Events
Sometimes users send messages such as an image, a video or special location messages, among others, to receive and start a conversation when a message of this type arrives we can use the events.
WELCOME
Default
When a user sends a "text" message that does not exist in a keyword on another flow, the WELCOME event will be triggered by default, which is the default event.
Let's imagine the case in which a person writes the word
Thank you!
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAnswer
(
'Ey welcome?'
)
const
greetingFlow
=
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Hi!'
)
Copy
Copied!
We can see in the diagram above that the bot does a search in all the flows to get the best flow that can respond to the keyword "Thank You" but as it does not find then the "WELCOME" is triggered.
MEDIA
Received Image or Video
When a user sends an image or a video, the MEDIA event, which is the default event, will be triggered by default. This is ideal for when we need them to send information and we need to store it.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
mediaFlow
=
addKeyword
(
EVENTS
.
MEDIA
)
.addAnswer
(
'I received a media image/video'
)
Copy
Copied!
To save the media file you must invoke the saveFile function from the provider you are using.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
mediaFlow
=
addKeyword
<
BaileysProvider
>(
EVENTS
.
MEDIA
)
.addAnswer
(
'I received a media image/video'
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
DOCUMENT
Received Document
When a user sends a document, DOCUMENT event will be triggered by default, which is the default event.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
documentFlow
=
addKeyword
(
EVENTS
.
DOCUMENT
)
.addAnswer
(
"Wow! I'm sorry I can't read this document right now"
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
LOCATION
Received Location
Location must be sent via WhatsApp, does not yet allow location links from external apps
When your chatbot needs to access a user's location, it's important to ensure that the location is sent directly from the WhatsApp app to have results. Once the location is received, you can perform a console log of ctx to view the details of the received location.
The received location context will look something like this in console:
ctx:
{
...
message:
Message
{
locationMessage:
LocationMessage
{
degreesLatitude:
-2.1462137699127197,
degreesLongitude:
-79.88981628417969,
name:
'Doctor Miguel Angel Jijón Teran'
,
address:
'Doctor Miguel Angel Jijón Teran, Guayaquil, Ecuador'
,
},
},
body:
'_event_location__0d5c9f57-0909-44a1-995f-902f9df3b21f'
,
name:
'yeyodev 👨🏾‍💻'
,
from:
'593000000000'
}
Copy
Copied!
This will output the user's latitude and longitude in the console, allowing you to effectively utilize the location data for your chatbot's functionality.
To access the location data, you can use the following approach:
location.flow.ts
location.flow.js
import
{ EVENTS
,
addKeyword }
from
"@builderbot/bot"
;
export
default
addKeyword
(
EVENTS
.
LOCATION
)
.addAnswer
(
"I have received your location!"
,
null
,
async
(ctx)
=>
{
const
userLatitude
=
ctx
.
message
.
locationMessage
.degreesLatitude;
const
userLongitude
=
ctx
.
message
.
locationMessage
.degreesLongitude;
})
Copy
Copied!
VOICE_NOTE
Received Voice Note
When a user sends a voice note, the VOICE_NOTE event will be triggered by default, which is the event intended for this behavior, it is important to understand that a voice note is different from an image or video file.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
voiceNoteFlow
=
addKeyword
(
EVENTS
.
VOICE_NOTE
)
.addAnswer
(
'Give me a second to hear you!'
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_methods.txt ---
Methods - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
State
GlobalState
FlowDynamic
FallBack
EndFlow
GotoFlow
Blacklist
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Methods
Inside each addAction or addAnswer we can execute logic and we can make use of some methods that will facilitate the development.
State
In many occasions you will need to share data between flows and no matter if you have modularized your project in different files you can use state in the callback function to be able to access the individual state of each user.
Let's imagine the case where you have two flows.
Flow A: In charge of collecting user data.
Flow B: Responsible for generating a record in the database.
but both flows are independent files
Remember
that the state is independent per conversation between user and bot.
app.ts
flow-a.ts
flow-b.ts
import
{ createFlow
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
;
// ...
import
flowA
from
'./flows/flow-a'
import
flowB
from
'./flows/flow-b'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([flowA
,
flowB])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
Copy
Copied!
Each conversation history with the user is totally independent, in this way we avoid mixing conversations.
It is important to understand that the state is volatile, it does not permeate anywhere. If you are worried about the performance level, you can see it
here
, but I'll save you time by telling you that it is a
Map
GlobalState
Very similar to
state
there is another method called GlobalState to share a global state of the bot between different flows. The main use for this method is to share data that can change and that every conversation between bot and user can access.
Below you can see a practical example where we use the globalState to use it as a switch to allow or disallow the bot to respond no matter who writes to it.
app.ts
flow-on-off.ts
flow-welcome.ts
import
{ createFlow
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
;
// ...
import
flowWelcome
from
'./flows/flow-welcome'
import
flowOnOff
from
'./flows/flow-on-off'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([flowWelcome
,
flowOnOff])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
Copy
Copied!
State/GlobalState Options
Both methods such as state and global state contain similar options and funcinalides, which depending on the use case can be very useful.
Clear
This method allows the state to be cleaned either globally or independently. It technically clears the Map.
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.clear
()
})
.addAction
(
async
(_
,
{ globalState })
=>
{
globalState
.clear
()
})
Copy
Copied!
Update
To add or update a value in the state we have available the update method. This method receives an object which if the value does not exist creates it and returns a new object with all the values.
It is important to understand that it is a promise to avoid rare behavior by adding the
await
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
await
state
.update
({name
:
'Joe'
,
age
:
'33'
})
await
state
.update
({email
:
'test@test.com'
})
})
.addAction
(
async
(_
,
{ globalState })
=>
{
await
globalState
.update
({name
:
'Joe'
,
age
:
'33'
})
await
globalState
.update
({email
:
'test@test.com'
})
})
Copy
Copied!
Get
When we need to retrieve the state values we can do it individually by calling by the property name as follows.
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.get
(
'propertyName'
)
})
.addAction
(
async
(_
,
{ globalState })
=>
{
globalState
.get
(
'propertyName'
)
})
Copy
Copied!
GetMyState
Another way to retrieve the entire state object belonging to a user-independent conversation is by using getMyState
Available in:
state
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.getMyState
()
})
Copy
Copied!
GetAllState
When we are working with the globalState and we want to retrieve all the properties object with their respective values you can use getAllState
Available in:
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ globalState })
=>
{
globalState
.getAllState
()
})
Copy
Copied!
FlowDynamic
Many times you will need to send messages coming from an API call or dynamic data from data base or from processes. In this case you should use
flowDynamic
.
flow-standalone.ts
flow-multiline.ts
flow-list.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowStandAlone
=
addKeyword
(
'register'
)
.addAnswer
(
'What is your name?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
const
responseName
=
ctx
.body
//.... db.insert({name:responseName})
await
flowDynamic
(
`Thanks for register
${
responseName
}
`
)
})
export
default
flowStandAlone
Copy
Copied!
It is NOT recommended to send many messages in a row because the
provider
may determine that it is spam.
If you want to send a list of products it is recommended to send a few products between 4 to 8 and you can ask the user what category of products and other details to filter and be able to respond with the ideal product list.
FlowDynamic Options
Name
body
Type
string
Description
You can send a message inside an object using the body property. It is ideal when you need to send a message apart from the message to send a media or to place a delay.
Name
delay
Type
number
Description
This is the number of milliseconds that will elapse before the message is sent.
Name
media
Type
string
Description
The url or local path of the file to send, must be a text string and if it is a URL it must be public.
const
flow
=
addKeyword
(
'register'
)
.addAction
(
async
(_
,
{ flowDynamic })
=>
{
await
flowDynamic
([{ body
:
`Thanks
${
responseName
}
`
}])
await
flowDynamic
([{
body
:
`message with 2 seconds delay`
,
delay
:
2000
}])
await
flowDynamic
([{
body
:
`Look at this`
,
media
:
`https://i.imgur.com/0HpzsEm.png`
}])
await
flowDynamic
([{
body
:
`Look at this`
,
media
:
join
(
'assets'
,
'file.pdf'
)
}])
})
Copy
Copied!
FallBack
The fallBack() function is a fundamental resource within a bot's interaction flow, used to handle invalid or unexpected responses from the user. When a user provides a message that does not match any keyword or expected response, the bot can invoke the fallBack() function to repeat the last message and wait for a valid response.
To integrate the fallBack() function into the bot interaction flow, it is used within the
addAnswer()
or
addAction()
method. Within this method, a condition is set that verifies whether the user's response is valid or not. In case the response does not meet the expected criteria, fallBack() is called to repeat the last message and request a valid response. For example:
flow-validate-email-custom-error.ts
flow-validate-email-default-error.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowEmailRegister
=
addKeyword
(
'hello'
)
.addAnswer
(
'What is your email?'
,
{capture
:
true
}
,
(ctx
,
{ fallBack })
=>
{
if
(
!
ctx
.
body
.includes
(
'@'
)) {
return
fallBack
(
`Ups! is not a valid email`
);
}
else
{
// db.insert({email:ctx.body})
}
});
Copy
Copied!
EndFlow
The endFlow function is used in chat applications or conversational user interfaces to end a flow of interaction with the user. Imagine a scenario where you are collecting information from a user in several steps, such as their name, email address and phone number, and at each step the user has the option to cancel the current operation.
By using endFlow, you can provide the user with an easy way to cancel the transaction at any time. For example, you could present a button or command that the user can activate to indicate that they wish to stop the current process. Once endFlow is triggered, the interaction flow is terminated and a final message can be displayed to the user, informing them that the request has been canceled.
In summary, endFlow improves the user experience by providing a clear and easy-to-use exit in case they decide to abandon the process at any stage of the interaction flow. This helps ensure a smoother and more satisfying user experience in conversational applications.
flow-validate-email-custom-error.ts
const
flowRegister
=
addKeyword
([
'Hi'
])
.addAnswer
(
[
'Hello!'
,
'To submit the form I need some data...'
,
'Write your *Name*'
]
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
endFlow
,
state })
=>
{
if
(
ctx
.body
===
'cancel'
) {
return
endFlow
(
`Your request has been canceled`
);
}
await
state
.update
({name
:
ctx
.body})
return
flowDynamic
(
`Nice to meet you *
${
ctx
.body
}
*, let's continue...`
);
}
)
.addAnswer
(
[
'I also need your last names'
]
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
endFlow
,
state })
=>
{
if
(
ctx
.body
===
'cancel'
) {
return
endFlow
();
}
await
state
.update
({lastName
:
ctx
.body})
return
flowDynamic
(
`Perfect *
${
ctx
.body
}
*, finally...`
);
}
)
Copy
Copied!
GotoFlow
The
gotoFlow
function allows the smooth transition between different interaction flows in a conversational application. This method is useful when you need to separate the interaction logic into different flows and direct the user from one flow to another according to certain conditions or events.
For example, suppose that in a virtual assistant application you have one flow for registered users and another for unregistered users. With
gotoFlow
, it is possible to direct a newly registered user from the unregistered user flow to the registered user flow, or vice versa, providing a personalized and consistent experience for each type of user.
In the code provided, it is shown how to use
gotoFlow
to direct the user to the corresponding flow according to their registration status. This helps to modularize the application logic and facilitates the management of multiple conversation flows.
flow-welcome.ts
flow-a.ts
flow-b.ts
app.ts
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
;
const
flowWelcome
=
addKeyword
(
'hi'
)
.addAnswer
(
'Welcome!'
,
null
,
async
(ctx
,
{ gotoFlow })
=>
{
// db.get(...)
const
userRegistered
=
true
;
if
(userRegistered)
return
gotoFlow
(flowRegistered);
return
gotoFlow
(flowUserNotRegistered);
});
export
default
flowWelcome
Copy
Copied!
It is important to note that the implementation of gotoFlow must have a return before
Blacklist
Many times we will need to add or manage a list of nuemers that we do not want to interact with our bot. For them there is a blacklist that contains a series of methods to add, remove and review numbers.
Imagine a case where you want to talk to a contact without the intervention of the bot. You could use this mechanism
flow-mute.ts
flow-check-if.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowMute
=
addKeyword
(
'hi'
)
.addAction
(
async
(ctx
,
{ flowDynamic
,
blacklist })
=>
{
// const dataFromDb = db.findOne({from:ctx.from}) simualte db query
const
dataFromDb
=
{muted
:
true
}
if
(
dataFromDb
.muted) {
blacklist
.add
(
ctx
.from)
await
flowDynamic
(
`
${
ctx
.from
}
! added to blacklist`
);
}
else
{
blacklist
.remove
(
ctx
.from)
await
flowDynamic
(
`
${
ctx
.from
}
! removed from blacklist`
);
}
});
export
default
flowMute
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_plugins.txt ---
CONTRIBUTING - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
CONTRIBUTING
Welcome
We're glad that you're interested in contributing to our project! Here you will find all the necessary information to start collaborating. You can contribute in various ways, whether it's updating the documentation, improving the code, reviewing pending issues in the
issues
, or even making financial contributions, which will be used for various purposes related to the development and maintenance of the project. You can see more details on how to make financial contributions
here
.
The main language we use in this project is TypeScript, which allows us to maintain readable and scalable code.
Frequent Questions
Here are some answers to frequently asked questions that may arise when contributing to the project:
What is Lerna?
You can find an explanation in this
video
.
How do I make commits effectively?
Here's a
video
that shows you how to do it.
What are our communication channels?
You can join our community on
Discord
.
Requirements:
Before starting to contribute to the project, make sure you have the following tools installed:
Node.js
: Version 18 or higher. You can download Node from
here
.
pnpm
: Package manager. You can install it by following the instructions
here
.
VSCode
: Code editor that we recommend, as it has useful plugins.
Conventional Commits
: VSCode plugin that helps you create semantic commits, following best practices. You can install it from
here
.
Get Starter
Make a fork
Before starting work on the project, fork it to your own GitHub account. This will allow you to work on your own copy of the repository. Click on the following link to fork:
here
.
Clone the Repository (from your fork)
Once you have forked the project, clone your own copy of the repository using the following command in your terminal:
git
clone
https://github.com/TU_USERNAME/bot-plugins
Copy
Copied!
Dependencies install
Go to the project folder and run the following commands to install the necessary dependencies:
cd
bot-plugins
pnpm
install
pnpm
run
build
Copy
Copied!
Create a new integration
To create a new integration, run the following command in your terminal:
pnpm
run
create.package
<
package_nam
e
>
Copy
Copied!
compile (build)
To compile the application, run the following command in your terminal. This will generate a dist directory within the monorepo packages.
npx
lerna
run
build
--scope=
<
package_name
>
Copy
Copied!
tests environments
Once you have run the build and everything is correct, run the following command in your terminal:
pnpm
run
copy.lib
Copy
Copied!
This command will copy the necessary files into the base_app folder. Make sure you have previously run npm install within the
base_app
folder. Then, from the root of your directory, run:
pnpm
run
copy.lib
Copy
Copied!
To start the assistant, run:
npm
run
dev
Copy
Copied!
It should work smoothly.
Test End-to-End (E2E)
All changes made must pass the
end-to-end
tests. These tests are run with the following command:
pnpm
run
test
Copy
Copied!
Make sure you have a test folder and files with the
.test.ts
extension for your
tests
.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_plugins_agents.txt ---
OpenAi Plugin - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Install
Langchain
Sign in
OpenAi Plugin
Before you start, you must make sure to have an API key from
OpenAI
Install
Install the library to make use of OpenAI:
npm
npm
install
@builderbot-plugins/openai-agents
Copy
Copied!
import
"dotenv/config"
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS } =
from
"@builderbot/bot"
;
import
BaileysProvider
from
"@builderbot/provider/baileys"
;
import
MockAdapter
from
"@builderbot/database/mock"
;
/** ... other flows importations */
import
{ EmployeesClass }
from
"@builderbot-plugins/openai-agents"
;
/**
* PLugin Configuration
*/
const
emplyeeInstace
=
new
EmployeesClass
({
apiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
model
:
"gpt-3.5-turbo-16k"
,
temperature
:
0
})
emplyeeInstace
.employees
([
{
name
:
"SALES_AGENT"
,
// NAME OF YOUR AGENT
description
:
// DESCRIPTION OF YOUR AGENT AND WHAT IT WILL DO
"I'm Rob, the friendly salesperson in charge of assisting you if you intend to buy or are interested in any product. My responses are brief."
,
flow
:
YOUR_FLOW_HERE
,
// YOUR FLOW IMPLEMENTATION
}
,
{
name
:
"EXPERT_AGENT"
,
description
:
"Hello, my name is Leifer. I am the specialized person in charge of resolving your doubts about our chatbot course, which is developed with Node.js and JavaScript. This course is designed to facilitate sales automation in your business. I will provide concise and direct answers to maximize your understanding."
flow: expertoFlow
,
}
])
/**
* ENTRY POINT!
* THIS NOT USE AI FOR MANAGE EVENTS
* WELCOME FLOW OR FIRTS FLOW
*/
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx
,
ctxFn)
=>
{
const
{
state
}
=
ctxFn
const
pluginAi
=
ctxFn
.
extensions
.employeesAddon
/** This function is the one that does the job */
/** Determine the flow and retrieva an employee object */
const
employeeDeterminated
=
await
pluginAi
.determine
(
ctx
.body)
if
(
!
employeeDeterminated
?.employee){
return
ctxFn
.flowDynamic
(
"Oops, I'm sorry, I don't understand. How can I help you?"
)
}
state
.update
({answer
:
employeeDeterminated
.answer})
pluginAi
.gotoFlow
(
employeeDeterminated
.employee
,
ctxFn)
})
const
expertFlow
=
addKeyword
(
EVENTS
.
ACTION
)
.addAction
(
async
(_
,
{state
,
flowDynamic})
=>
{
const
currentState
=
state
.getMyState
()
return
flowDynamic
(
currentState
.answer)
/** here come the answer by OpenAi pluggin */
})
// ----- INITIALIZE
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
();
const
adapterFlow
=
createFlow
([
welcomeFlow
,
expertFlow
/** ... other flows */
]);
const
adapterProvider
=
createProvider
(BaileysProvider);
const
configBot
=
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
const
configExtra
=
{
extensions
:
{
employeesAddon
:
emplyeeInstace
}
}
await
createBot
(configBot
,
configExtra);
};
main
();
Copy
Copied!
REFERENCES:
OpenAi-Agents
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_plugins_langchain.txt ---
Builderbot x Langchain - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Builderbot x Langchain
pnpm
pnpm
install
@builderbot-plugins/langchain
Copy
Copied!
This is a series of utilities that use AI based on the langchain framework
each class returns an addkeyword like the one we know, with 3 important methods
setKeyword
create a new addkeyword
setAIModel
create a model based on openai or gemini
create
create a new flow
each flow update the state and save the response that you expected user like
await state.update({  })
routingFlow.ts
structuredFlow.ts
aiFlow.ts
import
"dotenv/config"
import
{ EVENTS
,
MemoryDB
,
createBot
,
createFlow
,
createProvider }
from
"@builderbot/bot"
import
{ TelegramProvider }
from
"@builderbot-plugins/telegram"
import
{ createFlowRouting
,
structuredOutput }
from
"src"
import
z
from
"zod"
const
welcome
=
createFlowRouting
.setKeyword
(
EVENTS
.
WELCOME
)
.setIntentions
({
intentions
:
[
'greeting'
,
'closure'
]
,
description
:
`GREETING: if the user greets\nCLOSURE: if the user says goodbye or thanks for anything`
})
.setAIModel
({ modelName
:
'gemini'
})
.create
({
afterEnd
(flow) {
return
flow
.addAction
((_
,
{ state })
=>
{
console
.log
(
state
.get
(
'intention'
))
state
.clear
()
})
}
,
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(TelegramProvider)
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([welcome])
})
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_plugins_shopify.txt ---
Shopify - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Install
SmartFlows
NormalFlows
Tests
Accuracy
References
Agents
Langchain
Sign in
Shopify
If you need help to generate your Shopify API key you can visit these resources
Shopify Api Key
To integrate the plugin into your other flows, you need to install the library:
Install
npm
npm
install
@builderbot-plugins/shopify
Copy
Copied!
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ createShopifyFlow }
from
'@builderbot-plugins/shopify'
import
BaileysProvider
from
"@builderbot/provider/baileys"
;
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
})
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flow)
})
}
main
()
Copy
Copied!
SmartFlows
Okay, a smartflow is nothing more than a flow like we know, it's just that this one has something that makes it special!
That something is the ability to communicate with AI to understand what the user is trying to tell us.
To add a smartflow, follow the code I show you below
/* stuff code */
const
byeFlow
=
addKeyword
(
'bye'
)
.addAnswer
(
'bye, i hope see you soon'
);
const
smartFlowBye
=
{
name
:
'BYE_FLOW'
,
description
:
[
"I'm an expert in goodbyes,"
,
"I'm the right person to respond when the user says bye or is saying goodbye."
]
.join
(
' '
)
,
flow
:
byeFlow
}
const
extra
=
{
flows
:
[smartFlowBye]
}
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
,
}
,
extra)
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flows)
})
Copy
Copied!
The bot's response should be something like this.
NormalFlows
Sometimes we just need a common flow to provide immediate and controlled responses. In this case, let's simply add the flow to trigger an action when the user says thank you.
const
gratefullFlow
=
addKeyword
(
'/thanks/'
,
{ sensitive
:
false
,
regex
:
true
})
.addAnswer
(
"Thank you for trusting our store ❤️"
);
const
flows
=
flow
.concat
(gratefullFlow)
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
})
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flows)
})
Copy
Copied!
Tests
Some tests done in the plugin can be found at the following link.
The following tests were conducted in various real-life scenarios, ranging from unfamiliarity to ambiguity
Tests
Accuracy
ACCURACY FROM PLUGIN
The plugin was subjected to various conversational tests, ranging from direct questions to more conversational ones.
here somethings examples
The plugin has a 97% of preccision when the conversation is not ambiguous
The plugin has a 96% accuracy when the conversation is unambiguous. This means it is as accurate as the question itself.
This does not diminish its potential.
TODO:
Improve history conversation.
Manage ambiguous question in same flow.
Improve answer triguers by agents.
Dynamic language spoken by the user.
References
REFERENCE:
Shopify pluggin
Telegram provider
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_plugins_telegram.txt ---
Telegram - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Install
Shopify
Agents
Langchain
Sign in
Telegram
Create your first Telegram bot if you don't have one yet
create your firts Telegram bot
Implementing a new communication channel such as telegram without affecting the logic of your project is very simple. Below you can find the starting point to implement the new telegram provider.
Install
pnpm
npm
pnpm
install
@builderbot-plugins/telegram
Copy
Copied!
import
{ createBot
,
MemoryDB
,
createProvider
,
addKeyword
,
createFlow }
from
'@builderbot/bot'
import
{ TelegramProvider }
from
'@builderbot-plugins/telegram'
const
welcomeFlow
=
addKeyword
([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
'Your name is?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
([
`nice!
${
ctx
.body
}
`
,
'I will send you a funny image'
])
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
dataApi
=
await
fetch
(
`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`
)
const
[
imageUrl
]
=
await
dataApi
.json
()
await
flowDynamic
([{body
:
'😜'
,
media
:
imageUrl}])
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(TelegramProvider
,
{
token
:
'YOUR_TELEGRAM_TOKEN_HERE'
})
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
In this way we have already implemented a new provider for Telegram keeping the same logic.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers.txt ---
Providers - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Providers
Providers are in charge of providing the communication bridge between your bot and
whatsapp
,
telegram
or custom provider.
You can change your provider very easily without affecting the logic of your bot.
It is as simple as implementing the connector of the provider of your choice. At the moment we have integrations with more than four suppliers.
Whatsapp:
Meta
,
Twilio
,
Baileys
,
WPPConnect
,
Venom
,
Telegram
,
Custom Provider
Each provider may need to adjust access keys, settings, among other properties that are usually passed as an object in the
createProvider
function.
meta-provider.ts
twilio-provider.ts
baileys-provider.ts
venom-provider.ts
wppconnect-provider.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ MetaProvider }
from
'@builderbot/provider-meta'
;
export
type
IProvider
=
typeof
MetaProvider
export
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
'jwtToken'
,
numberId
:
'numberId'
,
verifyToken
:
'verifyToken'
,
version
:
'v16.0'
,
})
Copy
Copied!
Below you will find more information about each of these providers.
Meta
The
WhatsApp Business Platform
enables medium and large businesses to communicate with their customers on a large scale. You can initiate conversations with customers in just minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through the channel of their choice.
meta-provider.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ MetaProvider }
from
'@builderbot/provider-meta'
;
export
type
IProvider
=
typeof
MetaProvider
export
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
'jwtToken'
,
numberId
:
'numberId'
,
verifyToken
:
'verifyToken'
,
version
:
'v16.0'
,
})
Copy
Copied!
More info about Meta provider
Twilio
Twilio
is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communications APIs enable businesses to provide the right communication experience for their customers within web and mobile applications. By using Twilio APIs, developers can quickly add this functionality to an application, such as voice messaging, video calls, text messaging and more.
twilio-provider.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ TwilioProvider }
from
'@builderbot/provider-twilio'
;
export
type
IProvider
=
typeof
TwilioProvider
export
const
adapterProvider
=
createProvider
(TwilioProvider
,
{
accountSid
:
'YOUR_ACCOUNT_SID'
,
authToken
:
'YOUR_ACCOUNT_TOKEN'
,
vendorNumber
:
'+14155238886'
,
publicUrl
:
"public_url"
,
//optional
});
Copy
Copied!
More info about Twilio provider
Baileys
Baileys
is an open source project which allows sending messages, receiving messages and dozens of other features by implementing WebSocket in a version of whatsapp.
It is a project with great trajectory driven by people with great knowledge of the subject, you can deepen in this library directly in its documentation or
repository
.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
If you want to see more examples taking full advantage of this provider in conjunction with the builderbot library you can check this
@jorgechavarriaga
repository
baileys-provider.ts
baileys-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
;
export
type
IProvider
=
typeof
BaileysProvider
export
const
adapterProvider
=
createProvider
(BaileysProvider)
Copy
Copied!
Venom
Venom
is an open-source project that utilizes JavaScript to create high-performance bots for WhatsApp. It supports a wide range of interactions including customer care, media sending, AI-based phrase recognition, and various architectural designs tailored for WhatsApp.
You can visit their
official
website as the repository to understand other features you can use.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
venom-provider.ts
venom-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ VenomProvider }
from
'@builderbot/provider-venom'
;
export
type
IProvider
=
typeof
VenomProvider
export
const
adapterProvider
=
createProvider
(VenomProvider)
Copy
Copied!
WPPConnect
WPPConnect
is an open source project developed by the JavaScript community with the aim of exporting functions from WhatsApp Web to the node, which can be used to support the creation of any interaction, such as customer service, media sending, intelligence recognition based on phrases artificial and many other things, use your imagination
You can visit their official website as the
repository
to understand other features you can use.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
wppconnect-provider.ts
wppconnect-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ WPPConnectProvider }
from
'@builderbot/provider-wppconnect'
;
export
type
IProvider
=
typeof
WPPConnectProvider
export
const
adapterProvider
=
createProvider
(WPPConnectProvider)
Copy
Copied!
Wali.chat Provider
Custom Provider
Custom provider there is the possibility to build your own customized adapter, we know that there are many more providers that can be very useful, an example can be
Wali.chat
which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize and share data with your agents.
app.ts
provider/wali.ts
provider/wali.events.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ WaliProvider
as
Provider }
from
'./provider/wali'
const
PORT
=
process
.
env
.
PORT
??
3008
const
fullSamplesFlow
=
addKeyword
<
Provider
,
Database
>([
'samples'
,
utils
.setEvent
(
'SAMPLES'
)])
.addAnswer
(
`💪 I'll send you a lot files...`
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTJ0ZGdjd2syeXAwMjQ4aWdkcW04OWlqcXI3Ynh1ODkwZ25zZWZ1dCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/LCohAb657pSdHv0Q5h/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([fullSamplesFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
token
:
process
.
env
.
TOKEN
,
deviceId
:
process
.
env
.
DEVICE_ID
})
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_baileys.txt ---
Baileys Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
QR Code
Pairing code
Send Presence Update
Number Exists on WhatsApp
Profile Picture
Modifying Chats
Improve performance with Baileys
More examples
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Baileys Provider
The
Baileys
library originated as a project for CS-2362 at
Ashoka University
and is not affiliated
with or endorsed by WhatsApp. Use it at your own discretion and avoid spamming individuals. We discourage
the use of stalkerware, bulk messaging, or any automated messaging practices.
Baileys
is a free WhatsApp provider
that operates
via WhatsApp Web. It interacts directly with WhatsApp Web using a WebSocket and does not require Selenium or any
other browser. By avoiding Selenium or Chromium, Baileys conserves significant RAM resources.
Avoid using buttons and lists as they are not fully compatible. While they may display on some devices, they often fail to function as intended.
QR Code
Link device QR Code In the code below you can see the standard way to link a device by scanning the QR code with the whatsapp application.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Pairing code
Link device pairing code, In the code below you can see the alternative way to link the whatsapp account through a pairing code.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Send Presence Update
The method
sendPresenceUpdate
lets the person/group with id know whether you're online, offline, typing etc.
This method has the following signature:
(property) sendPresenceUpdate
:
(type
:
WAPresence
,
toJid
?:
string
)
=>
Promise
<void>
Copy
Copied!
WAPresence can be one of the following:
type
WAPresence
=
'unavailable'
|
'available'
|
'composing'
|
'recording'
|
'paused'
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms)
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Sending Presence Update*`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
await
flowDynamic
(
'This is an example of presence update'
)
await
provider
.
vendor
.sendPresenceUpdate
(
'recording'
,
ctx
.
key
.remoteJid)
await
waitT
(
5000
)
await
provider
.
vendor
.sendPresenceUpdate
(
'composing'
,
ctx
.
key
.remoteJid)
await
waitT
(
5000
)
await
flowDynamic
(
'Great!'
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Video Send Presence Update
Number Exists on WhatsApp
To check if an entered number exists on WhatsApp, you use the
onWhatsApp
method of the provider.
This method has the following signature:
onWhatsApp
:
(
...
jids
:
string
[])
=>
Promise
<{
exists
:
boolean
;
jid
:
string
;
}[]>
Copy
Copied!
This method accepts one or more phone numbers (JIDs) as arguments and returns a promise that resolves to an array of objects containing
the existence status (exists) and JID (jid) for each number.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Number Exist on Whatsapp*`
)
.addAnswer
(
'*Enter the number to check:*'
,
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
checkNumber
=
ctx
.body
try
{
const
onWhats
=
await
provider
.
vendor
.onWhatsApp
(checkNumber)
if
(onWhats[
0
]?.exists) {
await
flowDynamic
([
`*Exists:*
${
onWhats[
0
].exists
}
\n*JID:*
${
onWhats[
0
].jid
}
`
,
`*Object:*
${
JSON
.stringify
(onWhats
,
null
,
6
)
}
`
])
}
else
{
await
flowDynamic
(
`The number *
${
checkNumber
}
* does not exists on Whatsapp.`
)
}
}
catch
(error) {
await
flowDynamic
(
`*Error:*
${
error
}
`
);
}
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Profile Picture
The method
profilePictureUrl
allows us to retrieve the profile picture of a given number.
This method has the following signature:
(property) profilePictureUrl
:
(jid
:
string
,
type
?:
"image"
|
"preview"
,
timeoutMs
?:
number
)
=>
Promise
<
string
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *profile Picture*`
)
.addAnswer
(
'Enter number to check image profile: '
,
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic
,
fallBack
,
endFlow })
=>
{
const
check
=
ctx
.body
+
'@s.whatsapp.net'
try
{
const
imageProfile
=
await
provider
.
vendor
.profilePictureUrl
(
check
.replace
(
/\+/
g
,
''
)
,
'image'
,
10000
)
await
flowDynamic
([
{
body
:
'*Profile Picture:*'
,
media
:
imageProfile
}
])
return
endFlow
(
'End.'
)
}
catch
(error) {
await
flowDynamic
(
`Error:
${
error
.message
}
`
)
return
fallBack
(
'Try it again.'
)
}
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Modifying Chats
The chatModify method provides various options to modify a chat, including:
Archive a chat
Mute/unmute a chat
Mark a chat read/unread
Delete a message for me
Delete a chat
Pin/unpin a chat
Star/unstar a message
This method has the following signature:
(property) chatModify: (mod: ChatModification, jid: string) => Promise
Copy
Copied!
Delete a message for me
when the received message does not comply with my business logic rules. (Develop your own logic rules)
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
badWords
=
[
'fuck'
,
'ass hole'
,
'motherfucker'
]
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms);
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Delete User Message:*`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
resp
=
ctx
.
body
.toLocaleLowerCase
()
const
containsBadWord
=
badWords
.some
(word
=>
resp
.includes
(word))
const
id
=
ctx
.
key
.id
const
fromMe
=
ctx
.
key
.fromMe
const
timeStamp
=
ctx
.messageTimestamp
if
(containsBadWord) {
await
flowDynamic
(
'Your message is going to be deleted as you are sending inappropriate language.'
)
await
waitT
(
3500
)
try
{
await
provider
.
vendor
.chatModify
(
{ clear
:
{ messages
:
[{ id
:
id
,
fromMe
:
fromMe
,
timestamp
:
timeStamp }] } }
,
ctx
.
key
.remoteJid
)
await
flowDynamic
(
`Message deleted successfully.`
)
}
catch
(error) {
await
flowDynamic
(
`Error:
${
JSON
.stringify
(error
,
null
,
3
)
}
`
)
}
}
await
flowDynamic
(
'Welcome!'
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Delete user message
Improve performance with Baileys
Baileys is a powerful provider for WhatsApp, but its ability to listen and process a wide range of events in real-time can lead to significant resource consumption, especially for highly active accounts. This guide will help you optimize your builderbot.app bot's performance when using Baileys as a provider.
Quickly optimize your Baileys provider
Activate these options in your Baileys provider configuration to improve performance:
const
adapterProvider
=
createProvider
(Provider
,
{
experimentalStore
:
true
,
// Significantly reduces resource consumption
timeRelease
:
10800000
,
// Cleans up data every 3 hours (in milliseconds)
})
Copy
Copied!
In addition to this configuration I recommend a reboot every 12 or 24 hours depending on how active your bot is. You can follow this guide to
configure the restarts
Benefits:
experimentalStore: true
: Limits processing to individual messages only, drastically reducing resource usage.
timeRelease: 10800000
: Performs periodic cleanups of accumulated data every 3 hours.
Note
:
experimentalStore
may limit some advanced WhatsApp functionalities, especially for groups.
Types of monitored events
Baileys constantly monitors various types of events, including:
Individual messages
: Sending and receiving messages in one-on-one chats.
Group messages
: All activity in WhatsApp groups.
Read states
: Updates when messages are read.
Contact stories
: Posting and viewing of statuses/stories.
Message editing and deletion
: Changes to existing messages.
Reactions
: Emojis and other reactions to messages.
Profile updates
: Changes in profile pictures, statuses, etc.
Calls
: Notifications of incoming and outgoing calls.
Impact on resources
Constant processing
: Each event triggers processes in the bot, consuming CPU.
Data storage
: Events are recorded in "baileys_store.json", increasing storage usage.
Frequent overwriting
: The file is updated with each new event, which can be I/O intensive.
Exponential growth
: In very active accounts, the volume of events can grow rapidly.
Optimization strategies
1. Using ExperimentalStore
The
experimentalStore: true
option is an advanced feature in builderbot.app designed to significantly optimize the bot's resource usage.
How it works:
Limits listening and processing to only individual message events.
Drastically reduces resource consumption by ignoring other types of events.
Implementation:
const
adapterProvider
=
createProvider
(Provider
,
{
experimentalStore
:
true
,
timeRelease
:
10800000
,
// 3 hours in milliseconds
})
Copy
Copied!
Important limitations:
Only for individual messages
: Works exclusively with "message" type events for individual chats.
Not compatible with group functions
: Not suitable for bots requiring group functionalities.
Feature restriction
: Some advanced WhatsApp features may not work correctly.
2. Event filtering
Configure Baileys to ignore non-essential events for your bot. This can be done through provider configuration or by selectively handling events in your code.
3. Periodic cleanup
Use the
timeRelease
option or scheduled restarts to clear accumulated data. This helps keep the storage file size under control.
4. Selective monitoring
If possible, limit the number of chats or groups actively monitored. This can significantly reduce the number of processed events.
Implementation example
Here's an example of how to implement these strategies in your bot:
This example uses
experimentalStore
and
timeRelease
to optimize the bot's performance.
app.ts
app-experimental.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
timeRelease
:
10800000
,
// 3 hours in milliseconds
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
More examples
If you want to see more examples applying Baiely's functions you can check the links below
Delete Bot Message
Delete an existing message in the conversation
Blocked Users on Bot
Block Whatsapp user using the provider
Fetch Status
Retrieve all whatsapp profile status information
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_baileys_blocked-users.txt ---
Blocked Users on BOT - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Blocked Users on BOT
To check the blocked users on the BOT, you should use the 'fetchBlocklist()' method of the provider.
This method has the following signature:
(property) fetchBlocklist
:
()
=>
Promise
<
string[]
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *List Blocked Users on BOT:*`
)
.addAction
(
async
(_
,
{ provider
,
flowDynamic })
=>
{
const
blocked
=
await
provider
.
vendor
.fetchBlocklist
()
const
result
=
blocked
.map
((id
,
index)
=>
`id
${
index
+
1
}
:
${
id
}
`
)
.join
(
'\n'
);
await
flowDynamic
(
`*Blocked:*\n
${
result
}
`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_baileys_delete-bot-message.txt ---
Delete Bot Message - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Delete Bot Message
We can use the
sendMessage
method to delete a message sent by the bot. This method has the following signature:
(property) sendMessage
:
(jid
:
string
,
content
:
AnyMessageContent
,
options
?:
MiscMessageGenerationOptions
)
=>
Promise
<
proto
.WebMessageInfo
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms)
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example delete Message`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
number
=
ctx
.
key
.remoteJid
await
provider
.
vendor
.sendMessage
(number
,
{ text
:
`Next message is going to be deleted in 5 seconds.\n\n*
${
Date
()
}
*`
})
const
msg
=
await
provider
.
vendor
.sendMessage
(number
,
{ text
:
`This is the message to be deleted!!! `
})
await
waitT
(
5000
)
await
provider
.
vendor
.sendMessage
(number
,
{ delete
:
msg
.key })
await
flowDynamic
(
`*
${
Date
()
}
*\n\nMessage has been deleted!`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_baileys_fetchStatus.txt ---
Fetch Status - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Fetch Status
This method has the following signature:
(property) fetchStatus
:
(jid
:
string
)
=>
Promise
<{
status
:
string
;
setAt
:
Date
;
}>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Whatsapp Status*`
)
.addAction
(
async
(_
,
{ provider
,
flowDynamic })
=>
{
const
statusInfo
=
await
provider
.
vendor
.fetchStatus
(
PHONE_NUMBER
+
'@s.whatsapp.net'
)
console
.log
(statusInfo)
await
flowDynamic
(
`*Status Info for
${
PHONE_NUMBER
}
*:\n\nStatus: *
${
statusInfo
.status
}
*\nSet At:
${
statusInfo
.setAt
}
`
)
await
flowDynamic
(
`Enter phone number to check status:`
)
}
)
.addAction
(
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
statusR
=
await
provider
.
vendor
.fetchStatus
(
ctx
.body
+
'@s.whatsapp.net'
)
await
flowDynamic
(
`*Status for:*
${
ctx
.body
}
\n\nStatus: *
${
statusR
.status
}
*\nSet At:
${
statusR
.setAt
}
`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_meta.txt ---
Meta Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Requirements
Uses Cases
Meta tutorial video
What do I do now?
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Meta Provider
The
WhatsApp Business Platform
allows medium and large businesses to communicate with their customers on a large scale. You can start conversations with customers in just a few minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through their preferred channel.
Requirements
Register a
Facebook Developers
account.
You will need to verify your business and your application with official documents, the type of which may vary depending on your country.
You will need to associate an official phone number of your business with your account that is not linked to any other WhatsApp account, either regular or Business. For testing purposes, Meta provides a free phone number.
Meta offers
1000
free customer-initiated conversations to the bot, and 250 free bot-initiated conversations to the customer. Once this limit is reached, each additional conversation will have a cost that may vary depending on your country or region.
More info about Meta Deploy
Uses Cases
If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider.
Cases such as sending
buttons
,
lists
, or
native methods
directly with Meta
More info about Meta uses cases
Meta tutorial video
If you are one of those people who prefer to watch videos, here is a short tutorial on how to implement the Meta base.
Video Meta Provider
You must create a new application. To do this, click on the
Create application
button.
On this screen, you must select
Company or Business
.
In the next step, you must enter a name for your application, also enter a contact email address and select the Test Business application.
Now, go to the WhatsApp Settings section.
This is the part where you will find the access token and you can also see the number from where WhatsApp messages are sent and to where they will be sent. As you are in the trial version, you must register the numbers to which you want to send.
On this same page, you can find the Webhook section that we will soon need to use.
In the
main file
of the bot where you are implementing the meta adapter function, you are going to place the following data:
numberId:
You can find it on the previous page.
jwtToken:
You can find it on the previous page.
VerifyToken:
You can write whatever you want, it's like a keyword.
In the example below, you can see a suggestion of how this can be done by using environment variables
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
()
const
adapterFlow
=
createFlow
([flowPrincipal])
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
process
.
env
.
JWTOKEN
,
//EAARBW3ZBGU0UBAACDjtQIzI8JuEa.............
numberId
:
process
.
env
.
NUMBER_ID
,
//103975305758520
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
//LO_QUE_SEA,
version
:
'v16.0'
})
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
After executing the bot, you will find a message in the console similar to the following. Where you can find the URL for your
webhook
.
$
npm
start
>
node app.js
[meta]: Add this url
"WHEN A MESSAGE COMES IN"
[meta]: POST http://localhost:3000/webhook
[meta]: More information
in
the documentation
Copy
Copied!
What do I do now?
You will notice that the bot starts an HTTP service (endpoint) that must be online on a server so that you can connect it with Meta.
Option 1:
You can test locally through a proxy tunnel server. 
Download
ngork
, a free tool that will help with this.
This generates an online URL that we can use in the
WebHook
section of Meta
Option 2:
If you have already deployed your bot on a server, you need to obtain the public IP or subdomain provided to you.
Example
if you are using
Railway
, you can go to the settings section and generate a subdomain. We would then have the
WebHook
https://base-twilio-memory-production.up.railway.app/twilio-hook
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_meta_uses-cases.txt ---
Meta Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Meta Uses Cases
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ MetaProvider
as
Provider }
from
'@builderbot/provider-meta'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'ey'
,
'test'
])
.addAnswer
(
'send files...'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
}
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
.addAnswer
(
`First Way to Send Buttons`
,
{
buttons
:
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
})
.addAction
(
async
(ctx
,
{ provider })
=>
{
await
provider
.sendButtons
(
ctx
.from
,
[
{ body
:
'Option A'
}
,
{ body
:
'Option B'
}
,
{ body
:
'Option C'
}
]
,
`Send Buttons Alternative`
)
})
.addAction
(
async
(ctx
,
{ provider })
=>
{
await
provider
.sendButtonUrl
(
ctx
.from
,
{ body
:
'View Doc'
,
url
:
'https://builderbot.vercel.app'
}
,
'Send Buttons URL'
)
})
.addAnswer
(
'Send Contact'
,
null
,
async
(ctx
,
{ provider })
=>
{
await
provider
.sendContacts
(
ctx
.from
,
[
{
name
:
{
formatted_name
:
'Leifer'
,
first_name
:
'Leifer M'
}
,
phones
:
[{
phone
:
'34000000'
,
type
:
'HOME'
,
wa_id
:
'34000000'
// (optional) makes META identify the number as an active wpp user
}]
}
])
})
.addAnswer
(
'Send Location'
,
null
,
async
(ctx
,
{ provider })
=>
{
await
provider
.sendLocation
(
ctx
.from
,
{
address
:
'CDMX Centro'
,
lat_number
:
'19.3909832'
,
long_number
:
'-99.3084209'
,
name
:
'CDMX Office'
})
})
.addAnswer
(
'Send List'
,
null
,
async
(ctx
,
{ provider })
=>
{
const
list
=
{
"header"
:
{
"type"
:
"text"
,
"text"
:
"Weekly Promotions"
}
,
"body"
:
{
"text"
:
"Discover our amazing offers!"
}
,
"footer"
:
{
"text"
:
"Visit our website for more details"
}
,
"action"
:
{
"button"
:
"See more"
,
"sections"
:
[
{
"title"
:
"Clothing"
,
"rows"
:
[
{
"id"
:
"001"
,
"title"
:
"Printed T-shirt"
,
"description"
:
"Cotton t-shirt with printed design"
}
,
{
"id"
:
"002"
,
"title"
:
"Slim-fit Jeans"
,
"description"
:
"Slim-fit denim jeans for men and women"
}
]
}
,
{
"title"
:
"Electronics"
,
"rows"
:
[
{
"id"
:
"003"
,
"title"
:
"Smartphone"
,
"description"
:
"Smartphone with HD display and high-resolution camera"
}
,
{
"id"
:
"004"
,
"title"
:
"Wireless Headphones"
,
"description"
:
"Headphones with noise cancellation and Bluetooth connectivity"
}
]
}
]
}
};
await
provider
.sendList
(
ctx
.from
,
list)
})
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
jwtToken
:
process
.
env
.
JWT_TOKEN
,
numberId
:
process
.
env
.
NUMBER_ID
,
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
version
:
'v19.0'
})
const
adapterDB
=
new
Database
()
const
{
handleCtx
,
httpServer
}
=
await
createBot
<
Provider
>({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
adapterProvider
.
server
.post
(
'/v1/samples'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
,
message
,
urlMedia
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media
:
urlMedia
??
null
})
await
bot
.
provider
.sendMessage
(number
,
message
,
{})
await
bot
.
provider
.sendButtons
(number
,
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
,
'Send Buttons API'
)
await
bot
.
provider
.sendButtonUrl
(number
,
{
body
:
'View Doc'
,
url
:
'http://builderbot.app'
}
,
'Send Buttons API CTA'
)
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
adapterProvider
.
server
.post
(
'/v1/flow'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
}
=
req
.body
await
bot
.dispatch
(
'TEST'
,
{ from
:
number
,
name
:
'bot'
})
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
There are several features that the default provider does not provide and you can create them along the way
today I want to teach you a very basic but effective, the double tick or popcorn in English
Send Double Tick
to send the double tick or double popcorn you only need the ID of each new message that arrives, simple no?
let's see a clear example of this
app.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ MetaProvider }
from
'@builderbot/provider-meta'
const
PORT
=
process
.
env
.
PORT
??
3001
const
welcome
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx)
=>
{
/*
{
"messaging_product": "whatsapp",
"status": "read",
"message_id": "MESSAGE_ID"
}
*/
//all you need to add is the ID of each new message
provider
.sendMessageToApi
({
"messaging_product"
:
"whatsapp"
,
"status"
:
"read"
,
message_id
:
ctx
?.message_id
}
as
any
)
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(MetaProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([welcome])
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/register'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
name
}
=
req
.body
await
bot
.dispatch
(
'EVENT_REGISTER'
,
{ from
:
number
,
name })
return
res
.end
(
'trigger'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_twilio.txt ---
Twilio Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Send Buttons
Content Template Builder
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Provider
Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communication APIs empower businesses to provide the appropriate communication experience for their customers within web and mobile applications. By leveraging Twilio's APIs, developers can swiftly integrate functionalities such as voice messages, video calls, text messages, and more into an application.
Twilio provides you with a Sandbox account so you can try the service for free.
Register a Twilio account
.
If you want to take a closer look at the process of setting up your Twilio environment to start creating your chatbot, click here.
More info about Twilio Deploy
Uses Cases
If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider. Cases such as sending buttons, lists, or native methods directly with Meta
More info about Twilio uses cases
Send Buttons
One of the most requested functions by users is the fact of
sending buttons
to generate more interactivity and more dynamic chatbots.
app.ts
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'template'
,
'plantilla'
])
.addAction
(
async
(ctx)
=>
{
await
provider
.send
(
ctx
.from
,
'Agregar dos botones que permiten al cliente dar una respuesta mas rapida'
,
{
contentSid
:
'HXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
}
)
})
Copy
Copied!
Remember that the use of buttons, lists and other featured Whatsapp functionality needs to be a template authorized by the provider.
contentSid
is the id of the approved template you can use.
Content Quick
Remember for correct functionality you must have the message comply with the message template constructed.
Buttons Examples
Content Template Builder
The Content Template Builder is a Twilio product designed to create template messages and content-rich messages. It has an easy-to-use graphical interface built on a publicly accessible API. With the Content Template Builder, both engineers and non-technical users can create, approve and manage templates from the Twilio Console.
With this system, it is possible to create templates faster, with fewer errors, while empowering the entire team to contribute. Both developers and non-technical users can build and submit templates for approval from the Twilio Console without writing a single line of code.
Content Templates
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_twilio_deploy.txt ---
Twilio Setup - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Setup
Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communication APIs empower businesses to provide the appropriate communication experience for their customers within web and mobile applications. By leveraging Twilio's APIs, developers can swiftly integrate functionalities such as voice messages, video calls, text messages, and more into an application.
Twilio provides you with a Sandbox account so you can try the service for free.
Register a Twilio account
.
Requirements
We must accept the terms and conditions and then activate the sandbox account.
Sandbox
We note that we now have a WhatsApp number and a phrase. The number provided is a
trial number
that Twilio offers you, after you activate a payment plan you can purchase a number for your use. Save that number as a WhatsApp contact on your mobile and then send it the message assigned to you. In the example on the screen,
join score-state appears
Join to sandbox
Twilio then responds with a message confirming the connection verification.
This step is only necessary when you are in Sandbox mode
.
Test your Whatsapp
Now go to the WhatsApp Settings section located in the Twilio console.
In this section, you can configure the
Webhooks
that connect to the chatbot.
Don't know what your link is?
Continue reading this guide later you will understand.
You will also need the
Account SID and Auth Token
, these data are obtained from
console.twilio.com
.
What do I do with this data?
Save them or have them located because we will need them on the following screens.
In the
main file
of the bot where you are implementing the Twilio adapter function you are going to place the following data:
ACC_SID:
You will find it in the Twilio console, you can see the previous screen.
ACC_TOKEN:
You will find it in the Twilio console, you can see the previous screen.
ACC_VENDOR:
It is the WhatsApp number (if you already have the Twilio payment plan, use the number you purchased), if you are still in sandbox mode, use the number provided in step number 2.
In the example below you can see a suggestion of what it can be like using environment variables
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ TwilioProvider }
from
'@builderbot/provider-twilio'
const
welcomeFlow
=
addKeyword
<
TwilioProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(TwilioProvider
,
{
accountSid
:
process
.
env
.
ACC_SID
,
//AC4695aa720b4d700a***************
authToken
:
process
.
env
.
ACC_TOKEN
,
//3f6fae09f7a1c3534***************
vendorNumber
:
process
.
env
.
ACC_VENDOR
,
//+14155238886
})
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
After running the bot you will find a message in the console similar to the following. Where you can find the URL for your
webhook
$
npm
start
>
bot-whatsapp-base-twilio-memory@1.0.0 start
>
node app.js
[Twilio]: Agregar esta url
"WHEN A MESSAGE COMES IN"
[Twilio]: POST http://localhost:3000/twilio-hook
[Twilio]: Más información en la documentacion
Copy
Copied!
What do I do now?
You will see that the bot starts an HTTP service (endpoint) that must be on an online server so you can connect it to Twilio.
Option 1
You can test locally through a tunnel proxy server. Download
ngork
is a free tool that will help us with this.
This generates an inline URL that we can use in the
WebHook
part of Twilio
Option 2
If you already have your bot deployed on a server, you have to obtain the public IP or subdomain that they provided you. Example, if you are using
Railway
you can go to the settings section and generate a subdomain. We would already have the WebHook
https://base-twilio-memory-production.up.railway.app/twilio-hook
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_providers_twilio_uses-cases.txt ---
Twilio Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Uses Cases
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ TwilioProvider
as
Provider }
from
'@builderbot/provider-twilio'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'test'
])
.addAnswer
(
'send files...'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://builderbot.vercel.app/_next/static/media/logo-v2.5d15651a.png'
}
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
.addAnswer
(
`First Way to Send Buttons`
,
{
buttons
:
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
})
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
accountSid
:
process
.
env
.
ACCOUNT_SID
,
authToken
:
process
.
env
.
AUTH_TOKEN
,
vendorNumber
:
process
.
env
.
VENDOR_NUMBER
,
})
const
adapterDB
=
new
Database
()
const
{
handleCtx
,
httpServer
}
=
await
createBot
<
Provider
>({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
adapterProvider
.
server
.post
(
'/v1/samples'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
,
message
,
urlMedia
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media
:
urlMedia
??
null
})
await
bot
.
provider
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_quickstart.txt ---
Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Create
Requirements
Base Example
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Create
Creating a bot is as simple as running the following command and following the instructions
Prerequisites to consider before using this tool,
Node
v20 or higher and
Git
pnpm
npm
pnpm
create
builderbot@latest
Copy
Copied!
or you can use the following command to create a bot with the default configuration
pnpm
npm
pnpm
create
builderbot@latest
--provider=baileys
--database=memory
--language=ts
Copy
Copied!
Use the space key to select and the enter key to confirm. The CLI performs a preliminary check of the Node and operating system version, informing you if it meets the requirements or providing you with relevant information. In addition to generating a base project for you to simply start up
If you have problems with your terminal try running the command with
CMD, PowerShell, GitBash
or another console you have installed.
Requirements
Make sure you have installed Node version
20 or higher
, below you can see an example to check the version of node you are using.
Node Version
node
-v
v20.10.0
Copy
Copied!
Download node from its official website
It is recommended to have GIT installed for proper operation. If you are using Linux or MacOc you probably already have GIT installed by default.
Git Version
git
-v
git
version
XXXX
Copy
Copied!
Download GIT from its official website
Base Example
In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are:
info, hello, hi
. You can see how to create the bot and implement the
flows
.
main.ts
main.js
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
/** send static messages */
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
/** send dynamic message from db or other sources */
const
infoFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>(
'info'
)
.addAction
(
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
(
`Welcome
${
ctx
.name
}
`
)
})
/** send media files */
const
mediaFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>(
'image'
)
.addAnswer
(
`Send Image A`
,
{ media
:
'https://i.imgur.com/AsvWfUX.png'
})
.addAction
(
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
(
`Welcome
${
ctx
.name
}
`
)
await
flowDynamic
(
[
{
body
:
'Send Image B'
,
media
:
'https://i.imgur.com/w0RtKnN.png'
}
]
)
})
/** initialization bot */
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow
,
infoFlow
,
mediaFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_resources.txt ---
BuilderBot Brand Guidelines and Assets - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Logo Pack
Brand Assets
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
BuilderBot Brand Guidelines and Assets
Avoid representing the BuilderBot brand in a way that:
Implies partnership, sponsorship or endorsement.
Makes the BuilderBot brand the most distinctive or prominent feature.
Puts the BuilderBot brand in a negative context as part of a script or storyline. You must comply with our Terms of Use and Community Guidelines.
Keep the word BuilderBot consistent
Avoid representing the BuilderBot brand in a way that:
Keep the letters "B" in BuilderBot capitalized and in the same font size and style as the content surrounding it.
If you offer an app, website or a product or service that uses the BuilderBot APIs or is otherwise compatible with or related to BuilderBot, you may only use BuilderBot to say that your app is "for BuilderBot" or that the name of your campaign is "on BuilderBot" in a descriptive manner.
Don't modify, abbreviate or translate the word BuilderBot to a different language or by using non-English characters, or use any of our logos to replace it.
Don't combine "Builder" or "Bot" with your own brand.
Don't combine any part of the BuilderBot brand with a company name, other trademarks, or generic terms.
Distance BuilderBot from other platforms
BuilderBot may be mentioned in a television commercial with its parent company or other affiliated companies.
Don't mention other similar platforms in the same spot as BuilderBot, unless it's a general "Find us on..." call to action.
If you create a hashtag that uses the word Builder or Bot, it shouldn't be used on other platforms and you shouldn't try to acquire or enforce rights over that hashtag.
Logo Pack
I have read and accept the applicable guidelines and other terms for use.
Download BuilderBot Horizontal Logo (PNG)
Download BuilderBot Logo (SVG)
Download BuilderBot Logo (PNG)
Download BuilderBot Black Logo (PNG)
Download BuilderBot White Logo (PNG)
Download BuilderBot White Line Logo (PNG)
Download BuilderBot Full Logo (PNG)
Download BuilderBot Full Line Logo (PNG)
Download BuilderBot Transparent Line Logo (PNG)
Download BuilderBot Mini Logo (PNG)
Download BuilderBot Thumbnail Vector (PNG)
Brand Assets
Here's a color guide for inspiration that you can use
Teal
#20E3B2
Copy
Dark Blue
#0F172A
Copy
Light Gray
#F1F5F9
Copy
Dark Gray
#64748B
Copy
White
#FFFFFF
Copy
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_cron-reminder.txt ---
Reminder (cron) - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Reminder (cron)
Issue
I need to send individual reminders every so often to users, reminding them to perform a task or complete a purchase.
Possible Solution
For this we will need to install some dependencies that will facilitate the work of the scheduled tasks, we will use
node-cron
below you will find the instructions on how to install
install
pnpm
i
node-cron
pnpm
i
@types/node-cron
-D
Copy
Copied!
We have seen how we declare a logic that runs every 12 hours
0 */12 * * *
cron guru
where it makes a request to an api that can also be a query to the database to retrieve which are those user numbers to which we want to send a message.
It is recommended that you have a varied list of welcome messages to avoid possible bans.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ schedule }
from
'node-cron'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
/**
* It is recommended to have an array of messages with which you will
* greet or make that first contact with the user to
* avoid robotic behavior and possible bans
*/
schedule
(
'0 */12 * * *'
,
async
()
=>
{
console
.log
(
'running a task twelve hours'
);
const
usersApi
=
await
fetch
(
'http://your.api/users'
)
const
users
=
await
usersApi
.json
()
const
listMessages
=
[
`Your message!`
,
'Ey how are you?'
,
'How do you doing?'
]
for
(
const
user
of
users) {
const
randomMessage
=
listMessages[
Math
.floor
(
Math
.random
()
*
listMessages
.
length
)]
await
adapterProvider
.sendMessage
(
user
.number
,
randomMessage
,
{})
await
utils
.delay
(
5000
)
}
});
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_docker-pm2.txt ---
Scheduled Reboots - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Scheduled Reboots
Issue
Occasionally, the bot's programming seems to be unresponsive or the server does not have enough resources.
Possible Solution
When using the free providers we will need to restart the bot to avoid accumulating temporary data that may affect its performance. In that case an easy solution to implement is to schedule restarts, these restarts will not need to scan the QR again.
Docker and Pm2 One way to do it if you are using docker could be to implement in your docker image Pm2 and with pm2-runtime start your container with a cron pattern.
In the following Dockerfile we can see how we start the project with a pattern
0 */12 * * *
that means that it will restart every 12 hours
Dockerfile
# Use the official Node.js image as the base image for building the application.
FROM
node:21-alpine3.18
as
builder
# Enable Corepack and prepare for PNPM installation
RUN
corepack enable && corepack prepare pnpm@latest --activate
ENV
PNPM_HOME=/usr/local/bin
# Set the working directory inside the container
WORKDIR
/app
# Copy package.json and pnpm-lock.yaml files to the working directory
COPY
package*.json pnpm-lock.yaml ./
# Install git for potential dependencies
RUN
apk add --no-cache git
# Install PM2 globally using PNPM
RUN
pnpm install pm2 -g
# Copy the application source code into the container
COPY
. .
# Install dependencies using PNPM
RUN
pnpm install
# Create a new stage for deployment
FROM
builder
as
deploy
# Copy only necessary files and directories for deployment
COPY
--from=builder /app/src ./src
COPY
--from=builder /app/package.json /app/pnpm-lock.yaml ./
# Install production dependencies using frozen lock file
RUN
pnpm install --frozen-lockfile --production
# Define the command to start the application using PM2 runtime
CMD
[
"pm2-runtime"
,
"start"
,
"./src/app.js"
,
"--cron"
,
"0 */12 * * *"
]
Copy
Copied!
Remember that this is an alternative solution, and it is possible that its implementation could be improved.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_event-in-out-messages.txt ---
Incoming and outgoing messages - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Incoming and outgoing messages
Issue
Sometimes we will need to listen to the events of incoming or outgoing messages, this is often necessary when we are connecting our chatbot with third party UI applications.
Possible Solution
In the example below we show a code which you can execute and observe the messages in the console. The objective is to capture the incoming and outgoing message from the bot.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
(
'hello!'
)
.addAnswer
(
'Welcome!'
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
bot
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
bot
.httpServer
(
+
PORT
)
adapterProvider
.on
(
'message'
,
({ body
,
from })
=>
{
console
.log
(
`Message Payload:`
,
{ body
,
from })
})
bot
.on
(
'send_message'
,
({ answer
,
from })
=>
{
console
.log
(
`Send Message Payload:`
,
{ answer
,
from })
})
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_fast-entires.txt ---
Fast Entries - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Issue
Improved Solution
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Fast Entries
Issue
Sometimes it happens that people are impatient and write independent messages in a very short time gap preventing the bot to answer, which makes that each message is answered but not in the desired order.
Improved Solution
For this type of environment, we've implemented an enhanced functionality that introduces a margin of 3000ms for the user to write messages. Each time a user writes a message within this 3000ms window, it accumulates all the messages. After the margin time expires, the bot interprets everything as a single conversation.
This implementation ensures that before passing to the processing stage, all independent messages (e.g., 3) become one (1) and are processed as a single message.
In this example, we use
3000ms
(equal to 3 seconds) as the default gap, but you can modify this to your liking by adjusting the
gapSeconds
in the
QueueConfig
.
Video Fast Entries
fast-entires.ts
app.ts
/**
*
@file
multiUserMessageQueue.ts
*
@description
An improved functional implementation of a multi-user message queueing system with debounce functionality,
* ensuring separate conversation handling for each user.
*/
import
{ BotContext }
from
"@builderbot/bot/dist/types"
;
interface
Message
{
text
:
string
;
timestamp
:
number
;
}
interface
QueueConfig
{
gapMilliseconds
:
number
;
}
interface
UserQueue
{
messages
:
Message
[];
timer
:
NodeJS
.
Timeout
|
null
;
callback
:
((body
:
string
,
from
:
string
)
=>
void
)
|
null
;
}
interface
QueueState
{
queues
:
Map
<
string
,
UserQueue
>;
}
function
createInitialState
()
:
QueueState
{
return
{
queues
:
new
Map
()
};
}
function
resetTimer
(userQueue
:
UserQueue
)
:
UserQueue
{
if
(
userQueue
.timer) {
clearTimeout
(
userQueue
.timer);
}
return
{
...
userQueue
,
timer
:
null
};
}
function
processQueue
(messages
:
Message
[])
:
string
{
const
result
=
messages
.map
(message
=>
message
.text)
.join
(
" "
);
console
.log
(
'Accumulated messages:'
,
result);
return
result;
}
function
createMessageQueue
(config
:
QueueConfig
) {
let
state
:
QueueState
=
createInitialState
();
return
function
enqueueMessage
(ctx
:
BotContext
,
callback
:
(body
:
string
,
from
:
string
)
=>
void
)
:
void
{
const
from
=
ctx
.from;
const
messageBody
=
ctx
.body;
if
(
!
from
||
!
messageBody) {
console
.error
(
'Invalid message context:'
,
ctx);
return
;
}
console
.log
(
'Enqueueing:'
,
messageBody
,
'from:'
,
from);
let
userQueue
=
state
.
queues
.get
(from);
if
(
!
userQueue) {
userQueue
=
{ messages
:
[]
,
timer
:
null
,
callback
:
null
};
state
.
queues
.set
(from
,
userQueue);
}
userQueue
=
resetTimer
(userQueue);
userQueue
.
messages
.push
({ text
:
messageBody
,
timestamp
:
Date
.now
() });
userQueue
.callback
=
callback;
console
.log
(
'Messages for'
,
from
,
':'
,
userQueue
.messages);
if
(
!
userQueue
.timer) {
userQueue
.timer
=
setTimeout
(()
=>
{
const
currentQueue
=
state
.
queues
.get
(from);
if
(currentQueue) {
const
result
=
processQueue
(
currentQueue
.messages);
if
(
currentQueue
.callback) {
currentQueue
.callback
(result
,
from);
}
state
.
queues
.set
(from
,
{
...
currentQueue
,
messages
:
[]
,
timer
:
null
});
}
}
,
config
.gapMilliseconds);
}
state
.
queues
.set
(from
,
userQueue);
};
}
export
{ createMessageQueue
,
QueueConfig };
Copy
Copied!
Key Improvements in the New Implementation:
Functional Approach
: The new implementation uses a functional programming style, which can lead to more predictable and testable code.
Immutable State
: The state of the queue is managed immutably, which helps prevent unexpected side effects.
Flexible Configuration
: The
QueueConfig
interface allows for easy adjustment of the gap time.
Enhanced Error Handling
: The implementation includes try-catch blocks for better error management.
Callback-based Processing
: Instead of returning a promise, the new implementation uses a callback function, allowing for more flexible message processing.
Detailed Logging
: Console logs have been added at key points to aid in debugging and understanding the message flow.
Remember that while this implementation offers significant improvements, it's always possible to further optimize based on specific use cases and requirements.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_forward-conversation-to-human.txt ---
Forward conversation to human - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Forward conversation to human
Issue
I need to be able to stop the bot to continue the conversation with one person but still allow other people to see it.
Possible Solution
In this example let's imagine that the bot number is
ADMIN_NUMBER
the idea is that if a user writes me the bot will answer this is correct, but
I want to pause the bot for that user, what I do is write to my own number from the whatsapp with a phrase
Mute +34000000
assuming that the number
of the user I want to pause is
+34000000
and the logic I perform is to clean characters to only get
34000000
and check if it exists in a
blackList
if it is not found I add it in this way the bot stops responding to that
user and I can continue talking to the person and when I want to reactivate the bot for this person I write again
Mute +34000000
and if it is found it removes it from the blacklist is basically a switch.
app.ts
util.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ numberClean }
from
'./utils'
const
PORT
=
process
.
env
.
PORT
??
3008
const
ADMIN_NUMBER
=
process
.
env
.
ADMIN_NUMBER
const
blackListFlow
=
addKeyword
<
Provider
,
Database
>(
'mute'
)
.addAction
(
async
(ctx
,
{ blacklist
,
flowDynamic })
=>
{
if
(
ctx
.from
===
ADMIN_NUMBER
) {
const
toMute
=
numberClean
(
ctx
.body)
//Mute +34000000 message incoming
const
check
=
blacklist
.checkIf
(toMute)
if
(
!
check) {
blacklist
.add
(toMute)
await
flowDynamic
(
`❌
${
toMute
}
muted`
)
return
}
blacklist
.remove
(toMute)
await
flowDynamic
(
`🆗
${
toMute
}
unmuted`
)
return
}
})
const
fullSamplesFlow
=
addKeyword
<
Provider
,
Database
>([
'samples'
,
utils
.setEvent
(
'SAMPLES'
)])
.addAnswer
(
`💪 I'll send you a lot files...`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([fullSamplesFlow
,
blackListFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_gotoflow-use.txt ---
How to Use GotoFlow? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
How to Use GotoFlow?
Issue
I needed to be able to detect users that were already registered in my system so I need to make a get http query to my external system to check if that number was registered or not and depending on that divert it to a convenient flow.
Possible Solution
A possible solution is to make use of the gotoFlow to be able to divert the logic depending on the response of the http request to be able to verify if the user is registered in the database or is a new user.
registered in the database or is a new user.
app.ts
unregisteredUsersFlow.ts
registeredUsersFlow.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB
,
EVENTS }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
"@builderbot/provider-baileys"
;
import
registeredUsersFlow
from
"./flows/registeredUsersFlow"
;
import
unregisteredUsersFlow
from
"./flows/unregisteredUsersFlow"
;
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(_
,
{ gotoFlow
,
state })
=>
{
const
checkDB
=
await
fetch
(
"http://my.app.example/checkDB"
,
{
method
:
"POST"
,
body
:
JSON
.stringify
({ phoneNumber
:
state
.from })
,
headers
:
{
"Content-Type"
:
"application/json"
,
}
,
});
const
status
=
await
checkDB
.json
();
if
(status
===
undefined
) {
await
state
.update
({ Registration
:
false
});
return
gotoFlow
(unregisteredUsersFlow);
}
if
(status
===
true
) {
return
gotoFlow
(registeredUsersFlow);
}
}
);
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider);
const
database
=
new
MemoryDB
();
const
flow
=
createFlow
([welcomeFlow
,
registeredUsersFlow
,
unregisteredUsersFlow]);
await
createBot
({ flow
,
provider
,
database });
};
main
();
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_idle-optional.txt ---
Idle - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Idle
Issue
I need to wait for the customer's response but only for a limited time.
Possible Solution
The inactivity of flows in our business logic can become a nuisance, that is why we share the following resources as an alternative solution to this situation.
Create a file named
idle-custom.ts
and paste the following code:
idle-custom.ts
import
{ EVENTS
,
addKeyword }
from
'@builderbot/bot'
import
{ BotContext
,
TFlow }
from
'@builderbot/bot/dist/types'
;
// Object to store timers for each user
const
timers
=
{};
// Flow for handling inactivity
const
idleFlow
=
addKeyword
(
EVENTS
.
ACTION
)
.addAction
(
async
(_
,
{ endFlow })
=>
{
return
endFlow
(
"Response time has expired"
);
}
);
// Function to start the inactivity timer for a user
const
start
=
(ctx
:
BotContext
,
gotoFlow
:
(a
:
TFlow
)
=>
Promise
<
void
>
,
ms
:
number
)
=>
{
timers[
ctx
.from]
=
setTimeout
(()
=>
{
console
.log
(
`User timeout:
${
ctx
.from
}
`
);
return
gotoFlow
(idleFlow);
}
,
ms);
}
// Function to reset the inactivity timer for a user
const
reset
=
(ctx
:
BotContext
,
gotoFlow
:
(a
:
TFlow
)
=>
Promise
<
void
>
,
ms
:
number
)
=>
{
stop
(ctx);
if
(timers[
ctx
.from]) {
console
.log
(
`reset countdown for the user:
${
ctx
.from
}
`
);
clearTimeout
(timers[
ctx
.from]);
}
start
(ctx
,
gotoFlow
,
ms);
}
// Function to stop the inactivity timer for a user
const
stop
=
(ctx
:
BotContext
)
=>
{
if
(timers[
ctx
.from]) {
clearTimeout
(timers[
ctx
.from]);
}
}
export
{
start
,
reset
,
stop
,
idleFlow
,
}
Copy
Copied!
Remember
to add this flow to your project's main flow array
app.ts
import
{ idleFlow }
from
'./idle-custom'
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow
,
registerFlow
,
idleFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
Copy
Copied!
Start Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
Name
gotoFlow
Type
TFlow
Description
Function providing the execution flow
Name
ms
Type
number
Description
Number of milliseconds to be set
const
questionFlow
=
addKeyword
(
"hello"
)
.addAction
(
async
(ctx
,
{ gotoFlow })
=>
{
start
(ctx
,
gotoFlow
,
10000
)
})
Copy
Copied!
Reset Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
Name
gotoFlow
Type
TFlow
Description
Function providing the execution flow
Name
ms
Type
number
Description
Number of milliseconds to be set
// ...
.addAnswer
(
"Give me your last name"
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ lastName
:
ctx
.body });
}
)
// ...
Copy
Copied!
Stop Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
// ...
.addAnswer
(
"Thank you!"
,
null
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
stop
(ctx);
}
)
// ...
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@bot-whatsapp/bot'
import
{ MemoryDB
as
Database }
from
'@bot-whatsapp/bot'
import
{ BaileysProvider
as
Provider }
from
'@bot-whatsapp/provider-baileys'
import
{ idleFlow
,
reset
,
start
,
stop
,
}
from
'./idle-custom'
const
PORT
=
process
.
env
.
PORT
??
3008
const
questionFlow
=
addKeyword
(
"hello"
)
.addAction
(
async
(ctx
,
{ gotoFlow })
=>
start
(ctx
,
gotoFlow
,
10000
))
.addAnswer
(
[
"This is a test of the Home idle, if you do not respond within 10 seconds I will end the flow."
,
"Give me your name"
,
]
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ name
:
ctx
.body });
}
)
.addAnswer
(
"Give me your last name"
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ lastName
:
ctx
.body });
}
)
.addAnswer
(
"Finally, answer this simple question by typing the number between [1, 2]."
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
endFlow
,
fallBack })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
switch
(
ctx
.body) {
case
"1"
:
stop
(ctx);
return
endFlow
(
`Nice 1`
);
case
"2"
:
stop
(ctx);
return
endFlow
(
`Ok 2`
);
default
:
return
fallBack
(
`I only accept *numbers* that are between [1, 2].`
);
}
}
);
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([questionFlow
,
idleFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_modularize.txt ---
Modularize Flows - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Modularize Flows
Issue
My application grew so large that I was having trouble maintaining it and the code was becoming spaghetti code.
Possible Solution
As our projects grow we will need to implement a better way to maintain the project, in this case it is highly recommended to implement a module view.
In the following example we will show how we have migrated the modules to a directory, as well as the provider and the database.
app.ts
provider/index.ts
database/index.ts
flow/index.ts
flow/welcome.flow.ts
services/ai.ts
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
Copy
Copied!
An example of the scaffolding you can use in your project. Or a more user friendly folder structure.
structure
src
├── app.ts
├── database
│   └── index.ts
├── flow
│   ├── index.ts
│   └── welcome.flow.ts
│   └── bye.flow.ts
│   └── media.flow.ts
├── provider
│   └── index.ts
└── services
    └── ai.ts
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_multiple-messages.txt ---
Multiple messages - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Multiple messages
Issue
Sometimes, you need the bot to generate responses based on an event such as receiving images from users, but you don't want the bot to throw multiple and redundant responses if the user quickly sends several images.
Possible Solution
To ensure that the bot responds only once despite receiving too many calls in a short period of time, a debounce decorator could be implemented around the gotoFlow and endFlow methods.
In the example below I will show you how I implemented this solution in my bot to analyze several images and depending on whether they are images of furniture or not, terminate the flow with an error message or send it to another registration flow
media-flow.ts
debounce.ts
import
path
from
"node:path"
;
import
fs
from
"node:fs/promises"
;
import
process
from
"node:process"
;
import
{ addKeyword
,
EVENTS }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
"@builderbot/provider-baileys"
;
import
{ UrlToBase64 }
from
"@builderbot-plugins/url-to-base64"
;
import
{ PROMPT_IMAGE }
from
"./prompt"
;
import
{ debounce }
from
"~/utils/debounce"
;
import
AIClass
from
"~/services/OpenAIService"
;
import
{ registerFlow }
from
"../order/register.flow"
;
const
localPaths
=
[];
let
debouncedEndFlow
:
(
...
args
:
any
[])
=>
void
;
let
debouncedGoToFlow
:
(
...
args
:
any
[])
=>
void
;
const
filePath
=
path
.join
(
process
.cwd
()
,
'src'
,
'database'
,
'images'
);
export
const
mediaFlow
=
addKeyword
<
BaileysProvider
>(
EVENTS
.
MEDIA
)
.addAction
(
async
(ctx
,
{ provider
,
queue })
=>
{
await
queue
.enqueue
(
'processImage'
,
async
()
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{ path
:
filePath });
localPaths
.push
(localPath);
}
,
'imageProcessingTask'
);
await
queue
.processQueue
(
'processImage'
);
await
queue
.clearQueue
(
'processImage'
);
queue
.clearAndDone
(
'processImage'
,
{fingerIdRef
:
'imageProcessingTask'
});
})
.addAction
(
async
(_
,
{ extensions
,
gotoFlow
,
endFlow })
=>
{
const
ai
=
extensions
.ai
as
AIClass
;
if
(
!
debouncedEndFlow
&&
!
debouncedGoToFlow){
debouncedEndFlow
=
debounce
(endFlow
,
1500
);
debouncedGoToFlow
=
debounce
(gotoFlow
,
1500
);
}
for
(
const
path
of
localPaths) {
const
{
data
,
mimetype
}
=
UrlToBase64
.fromFilePath
(path);
const
aiResponse
=
await
ai
.readImage
(data
,
PROMPT_IMAGE
,
mimetype);
if
(
aiResponse
.includes
(
'NOT_FURNITURE'
)) {
for
(
const
filePath
of
localPaths) {
await
fs
.unlink
(filePath);
}
localPaths
.
length
=
0
;
return
debouncedEndFlow
(
'Ups! Asegurate de enviar una foto correcta de un mueble'
);
}
}
localPaths
.
length
=
0
;
return
debouncedGoToFlow
(registerFlow)
})
Copy
Copied!
Remember that this is an alternative solution, and it is possible that its implementation could be improved.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_showcases_queue-limit.txt ---
Queue Limit - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Queue Limit
Issue
The problem was that when more than 60 people started a conversation in less than 20 seconds the bot did not respond to all the people.
Possible Solution
The framework by default implements a queue manager based on per-user work promises.
If you already understand the concept and you are in an environment where you receive a considerable number of recurring messages in a short period of time and you notice that it answers a large number of users but not all of them. You can try extending the process queue configuration.
Imagine the case
in which you receive more than 60 messages from more than 60 people in a very short period of time of less than 20 seconds for example
It is very likely that it will not respond to all users, since the default configuration of the bot is set to handle a smaller amount of processes, but it is very easy to modify.
app.ts
const
main
=
async
() => {
await
createBot
({
database:
new
MemoryDB
()
,
provider:
createProvider
(
BaileysProvider
)
,
flow:
createFlow
([...])
}, {
queue:
{
timeout:
20000
,
//👌
concurrencyLimit:
50
//👌
}
})
}
Copy
Copied!
Name
timeout
Type
number
Description
Number of milliseconds used as maximum duration for the execution of an asynchronous function.
default 20000
Name
concurrencyLimit
Type
number
Description
Number of parallel processes you can be running at the same time.
default 15
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_tutorials_api-use.txt ---
How to implement a REST API? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Send Single Message
Send with Media
Block Users
Trigger Flows
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
How to implement a REST API?
In many occasions we need to send a message via HTTP request is very useful to send reminders or order confirmations. In this case each provider implements a
handleCtx
function which allows you to inject the bot instantiation and access its functions from a controller.
Send Single Message
Request
POST
/v1/messages
curl
https://api.example.chat/v1/messages
\
-d
number=
"34000000"
\
-d
message=
"Hello!"
Copy
Copied!
In the exercise below you can get an example of how it works. It is interesting to understand that internally the library already implements a very light version of HTTP similar to express but called
polka
.
app.ts
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Send with Media
Request
Media Link
Media Local
POST
/v1/messages
curl
https://api.example.chat/v1/messages
\
-d
number=
"34000000"
\
-d
message=
"Ey! send media"
Copy
Copied!
In the following example you will understand how to send files, images or videos from an api when the file is in a public URL or also if you want to upload it through a request.
app-media.ts
app-media.storage.ts
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
,
media
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media })
// https://i.imgur.com/0HpzsEm.png
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Block Users
Request
POST
/v1/blacklist
curl
https://api.example.chat/v1/blacklist
\
-d
number=
"34000000"
\
-d
intent=
"'add' or 'remove'"
Copy
Copied!
In the following example you will understand how to add numbers to a blacklist to prevent the bot from answering those numbers, very useful when we want to talk to a person without the bot answering.
blacklist-api.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/blacklist'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
intent
}
=
req
.body
if
(intent
===
'remove'
)
bot
.
blacklist
.remove
(
`340000000`
)
if
(intent
===
'add'
)
bot
.
blacklist
.add
(
`340000000`
)
res
.writeHead
(
200
,
{
'Content-Type'
:
'application/json'
})
return
res
.end
(
JSON
.stringify
({ status
:
'ok'
,
number
,
intent }))
}))
}
main
()
Copy
Copied!
Trigger Flows
Request
POST
/v1/register
curl
https://api.example.chat/v1/register
\
-d
number=
"34000000"
\
-d
name
=
"Joe"
Copy
Copied!
In the following example you will understand how to start a flow to a given number from an API request, it is a new experimental function that may undergo changes in the future.
trigger-flow-api.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3001
const
registerFlow
=
addKeyword
(
utils
.setEvent
(
'EVENT_REGISTER'
))
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAnswer
(
'What is your age?'
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ age
:
ctx
.body })
})
.addAction
(
async
(_
,
{ flowDynamic
,
state })
=>
{
await
flowDynamic
(
`
${
state
.get
(
'name'
)
}
, thanks for your information!: Your age:
${
state
.get
(
'age'
)
}
`
)
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([registerFlow])
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/register'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
name
}
=
req
.body
await
bot
.dispatch
(
'EVENT_REGISTER'
,
{ from
:
number
,
name })
return
res
.end
(
'trigger'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_tutorials_chatbot-with-gemini.txt ---
Chatbot with Context - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Install Gemini
Context Example
Vision Example
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Chatbot with Context
The gemini model is a generous and valuable resource to use if it comes to creating a product with AI that has both vision and text generation and without spending a penny is what we want.
To start remember to install the gemini plugin and have your
Google Api key
Install Gemini
We started the installation of a package that will help you to implement the Gemin power in builderbot.
pnpm
install
@builderbot-plugins/gemini-layer
Copy
Copied!
More info about it
Context Example
Sometimes we don't want to place so many keywords or answers in validations of our flows, we want some freedom when it comes to responding, that's why we have the gemini plugin to respond based on a context
the context indicates between key value, the different scenarios in which the user may be when interacting with the assistant
context
: It is the object that will contain all the necessary properties you need.
layers/context.layer.ts
flows/context.flow.ts
app.ts
import
{ geminiLayer }
from
"@builderbot-plugins/gemini-layer"
export
default
async
(
...
bot
:
any
)
=>
await
geminiLayer
({
context
:
{
name
:
'your name'
,
email
:
'your email'
,
summary
:
'your summary'
// and more properties
}
}
,
bot)
Copy
Copied!
Vision Example
Field
Description
vision
true
visionPrompt
What you want the model to see
image_path
The route where the image will be downloaded to be analyzed later
cb
A callback that receives the same interface as addAction and which returns an answer in the state
layers/image.layer.ts
flows/image.flow.ts
app.ts
import
{ geminiLayer }
from
"@builderbot-plugins/gemini-layer"
const
visionPrompt
=
'Give me a brief summary of what you see in the picture'
export
default
async
(
...
bot
:
any
)
=>
await
geminiLayer
({
vision
:
true
,
visionPrompt
,
image_path
:
'./'
,
cb
:
async
(_
,
{ state
,
gotoFlow })
=>
{
const
{
answer
}
=
state
.getMyState
()
console
.log
(
'answer about image'
,
answer)
if
(answer
===
'anything else you want to validate'
) {
return
gotoFlow
(
'any flow you want to go'
)
}
}
}
,
bot)
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_tutorials_langchain.txt ---
Langchain - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Install
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Langchain
When we want something more personality and intelligence in our assistants, the first thing we think about is Openai, what if I tell you that there is a simple way to get the most out of your LLM?
Install
let's look at a simple but very valuable trick. to be able to know the user's intention, we have tried it before with DialogFlow but what a headache, let's go for something easier
pnpm
i
@langchain/openai
@langchain/core
zod
Copy
Copied!
ai/catch-intention.ts
app.ts
import
{ z }
from
"zod"
;
import
{ ChatOpenAI
,
ChatPromptTemplate }
from
"@langchain/openai"
;
export
const
openAI
=
new
ChatOpenAI
({
modelName
:
'gpt-4'
,
openAIApiKey
:
'YOUR_API_KEY_HERE'
,
});
const
SYSTEM_STRUCT
=
`just only history based:
{history}
Answer the users question as best as possible.`
;
export
const
PROMPT_STRUCT
=
ChatPromptTemplate
.fromMessages
([
[
"system"
,
SYSTEM_STRUCT
]
,
[
"human"
,
"{question}"
]
]);
const
catchIntention
=
z
.object
(
{
intention
:
z
.enum
([
'UNKNOWN'
,
'SALES'
,
'GREETING'
,
'CLOSURE'
])
.describe
(
'Categorize the following conversation and decide what the intention is'
)
}
)
.describe
(
'Given the following products, you should structure it in the best way, do not alter or edit anything'
);
const
llmWithToolsCatchIntention
=
openAI
.withStructuredOutput
(catchIntention
,
{
name
:
"CatchIntention"
,
});
export
const
getIntention
=
async
(text
:
string
)
:
Promise
<
string
>
=>
{
try
{
const
{
intention
}
=
await
PROMPT_STRUCT
.pipe
(llmWithToolsCatchIntention)
.invoke
({
question
:
text
,
history
:
await
history
.getHistory
(state)
});
return
Promise
.resolve
(
String
(intention)
.toLocaleLowerCase
());
}
catch
(errorIntention) {
return
Promise
.resolve
(
'unknown'
);
}
};
Copy
Copied!
That way you can validate the intentions of your end customer and set up your own purchase flow as easy as that
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_tutorials_migrate-to-builderbot.txt ---
Migrating from bot-whatsapp to builderbot: A Simple Guide - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
Key Differences
Easy Migration Steps
Code Comparison
Final Considerations
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Migrating from bot-whatsapp to builderbot: A Simple Guide
builderbot is the next evolution of bot-whatsapp, maintaining 99% compatibility while introducing significant improvements. This guide will walk you through the straightforward migration process.
Key Differences
Name Change
: From bot-whatsapp to builderbot
Enhanced Language Support
: Now includes TypeScript in addition to JavaScript
Improved Features
: New functionalities while maintaining familiar concepts
Easy Migration Steps
Update Dependencies
First, install the latest builderbot core:
npm
install
@builderbot/bot@latest
# or
pnpm
add
@builderbot/bot@latest
Copy
Copied!
Install Your Preferred Provider
Choose and install the provider you're using:
baileys
meta
twilio
venom
wppconnect
whatsapp-web
pnpm
install
@builderbot/provider-baileys@latest
Copy
Copied!
Update Imports
Modify your imports to use builderbot:
// Old
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
}
=
require
(
'@bot-whatsapp/bot'
)
// New
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB
}
=
require
(
'@builderbot/bot'
)
Copy
Copied!
Update Provider
Change the provider import and initialization:
// Old
const
WebWhatsappProvider
=
require
(
'@bot-whatsapp/provider/web-whatsapp'
)
// New
const
{
BaileysProvider
}
=
require
(
'@builderbot/bot'
)
// When initializing:
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
// New feature in builderbot
Copy
Copied!
Update Database
Update your database adapter:
// Old
const
MockAdapter
=
require
(
'@bot-whatsapp/database/mock'
)
const
adapterDB
=
new
MockAdapter
()
// New
const
{
MemoryDB
}
=
require
(
'@builderbot/bot'
)
const
adapterDB
=
new
MemoryDB
()
Copy
Copied!
Review and Update Flows
While most of your flows will work as-is, consider using new features like
addAction
for more complex logic:
const
infoFlow
=
addKeyword
(
'info'
)
.addAction
(
async
(ctx
,
{ flowDynamix })
=>
{
await
flowDynamix
(
`Welcome
${
ctx
.name
}
`
)
})
Copy
Copied!
Code Comparison
Here's a side-by-side comparison of a basic bot setup in bot-whatsapp and builderbot:
bot-whatsapp
builderbot
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
}
=
require
(
'@bot-whatsapp/bot'
)
const
BaileysProvider
=
require
(
'@bot-whatsapp/provider/baileys'
)
const
MockAdapter
=
require
(
'@bot-whatsapp/database/mock'
)
const
flowPrincipal
=
addKeyword
([
'hola'
,
'alo'
])
.addAnswer
([
'Hola, bienvenido a mi tienda'
,
'¿Como puedo ayudarte?'
])
.addAnswer
([
'Tengo:'
,
'Zapatos'
,
'Bolsos'
,
'etc ...'
])
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
()
const
adapterFlow
=
createFlow
([flowPrincipal])
const
adapterProvider
=
createProvider
(BaileysProvider)
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Final Considerations
Migration should be relatively straightforward due to high compatibility
Take advantage of new builderbot features, especially if you opt to use TypeScript
Maintain your existing development practices and patterns, as they remain valid
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de en_uses-cases.txt ---
Examples - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
How to Update to the Latest Version
My first bot
Conversational history
state
Dynamic Messages
flowDynamic
Send File
Switch to another flow
gotoFlow
Turn off bot a certain user
state
Turn off for everyone
state
Bot Self-Interaction
state
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Examples
Below you will find different examples showing the implementation in different use cases. These examples have been compiled based on the community, feel free to post an example that you like or that you think would be useful for new people.
How to Update to the Latest Version
To ensure you're using the most up-to-date features and bug fixes, it's important to keep your BuilderBot installation current. Follow the steps below to update to the latest version.
To keep your project up to date, make sure to run the command to update the core and the corresponding provider
pnpm
install
@builderbot/bot@latest
pnpm
install
@builderbot/provider-baileys@latest
pnpm
install
@builderbot/provider-wppconnect@latest
pnpm
install
@builderbot/provider-venom@latest
pnpm
install
@builderbot/provider-meta@latest
pnpm
install
@builderbot/provider-twilio@latest
Copy
Copied!
My first bot
The following code represents the quick use of a bot that when you type the word
hi
, greets you with a welcome message and asks you for your name and then returns a funny image
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
'Your name is?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
([
`nice!
${
ctx
.body
}
`
,
'I will send you a funny image'
])
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
dataApi
=
await
fetch
(
`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`
)
const
[
imageUrl
]
=
await
dataApi
.json
()
await
flowDynamic
([{body
:
'😜'
,
media
:
imageUrl}])
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
state
Conversational history
Often, we will need to manage conversations and keep the context in a memory called
state
which is volatile and accessible from any function executed in a stream.
const
welcomeFlow
=
addKeyword
([
'hello'
])
.addAnswer
(
"¿What's your name?"
,
{capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
=>
{
await
state
.update
({ name
:
ctx
.body })
await
flowDynamic
(
'Thanks for giving me your name!'
)
}
)
.addAnswer
(
'¿How old are you?'
,
{capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
=>
{
const
name
=
state
.get
(
'name'
)
await
state
.update
({ age
:
ctx
.body })
await
flowDynamic
(
`Thanks for sharing your age!
${
name
}
`
)
}
)
.addAnswer
(
'Here is your data:'
,
null
,
async
(_
,
{ flowDynamic
,
state })
=>
{
const
myState
=
state
.getMyState
()
await
flowDynamic
(
`Name:
${
myState
.name
}
Age:
${
myState
.age
}
`
)
})
Copy
Copied!
flowDynamic
Dynamic Messages
In other occasions we need to send messages in a dynamic way of data that can be variable, below you can see an example of how you should do it and how you should NOT do it.
❌ Avoid it this, does not work because addAnswer serializes the content at the start of execution.
let
name
=
''
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx)
=>
{
name
=
ctx
.body
})
.addAnswer
(
`Your name is:
${
name
}
`
)
Copy
Copied!
If you want to send a dynamic message use flowDynamic.
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
Copy
Copied!
Send File
When you want to
send an image, audio
, file or any other file you can do it this way. It is
important
to note that the URL must be
publicly accessible
.
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
}
)
.addAnswer
(
`Send video from Local`
,
{ media
:
join
(
process
.cwd
()
,
'assets'
,
'sample.png'
) }
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
Copy
Copied!
Other ways to use when the route is coming from a dynamic data source
const
flow
=
addKeyword
(
'hello'
)
.addAction
(
async
(_
,
{flowDynamic})
=>
{
// ...db get source...
await
flowDynamic
([
{body
:
'This is an image'
,
media
:
'https://i.imgur.com/0HpzsEm.png'
}
])
await
flowDynamic
([
{body
:
'This is a video'
,
media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
])
})
Copy
Copied!
If you need to send a file that is stored locally you can do that too. The use of
join
is recommended to ensure correct directory concatenation.
const
flow
=
addKeyword
(
'hello'
)
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
pathLocal
=
join
(
'assets'
,
'doc.pdf'
)
// pathLocal = c:/doc.pdf
await
flowDynamic
([
{body
:
'This is a video'
,
media
:
pathLocal }
])
})
Copy
Copied!
gotoFlow
Switch to another flow
If you want to divert a conversational flow to another logic flow based on a response input you can do it in this way:
const
flowToA
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option A!'
)
const
flowToB
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option B!'
)
const
flowToC
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option C!'
)
const
flowDefault
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
"We don't have that Option 🤔"
)
const
flow
=
addKeyword
(
'order'
)
.addAnswer
(
[
`Which one is the best option for you?`
,
`Type **A**`
,
`Type **B**`
,
`Type **C**`
,
]
,
{ capture
:
true
}
)
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
const
userAnswer
=
ctx
.body
if
(userAnswer
===
'A'
){
return
gotoFlow
(flowToA)
}
if
(userAnswer
===
'B'
){
return
gotoFlow
(flowToB)
}
if
(userAnswer
===
'C'
){
return
gotoFlow
(flowToC)
}
return
gotoFlow
(flowDefault)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
❌ This does not work, the invocation of the gotoFlow function must necessarily include a return.
//...Previous code...
...
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
gotoFlow
(flowToA)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
This does work
//...Previous code...
...
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
return
gotoFlow
(flowToA)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
state
Turn off bot a certain user
Sometimes we will need to turn off the bot for a certain user, so that we can have a conversation with the client without the bot interfering.
const
flow
=
addKeyword
<
BaileysProvider
>(
'magic keyword'
)
.addAction
(
async
(_
,
{ state
,
endFlow })
=>
{
const
botOffForThisUser
=
state
.get
<
boolean
>(
'botOffForThisUser'
)
await
state
.update
({botOffForThisUser
:!
botOffForThisUser})
if
(botOffForThisUser)
return
endFlow
()
})
.addAnswer
(
'Hello!'
)
Copy
Copied!
state
Turn off for everyone
Sometimes we will need to disable the bot for all people, without the need to shut down the server or stop the script.
const
flow
=
addKeyword
<
BaileysProvider
>(
'botoff'
)
.addAction
(
async
(_
,
{ globalState
,
endFlow })
=>
{
const
botOffForEveryOne
=
globalState
.get
<
boolean
>(
'botOffForEveryOne'
)
await
globalState
.update
({botOffForEveryOne
:!
botOffForEveryOne})
if
(botOffForEveryOne)
return
endFlow
()
})
.addAnswer
(
'Hello!'
)
Copy
Copied!
state
Bot Self-Interaction
In certain scenarios, it is necessary for the bot's phone number (host) to be able to interact within logical flows. To achieve this, we have several configurable options:
host:
This is used when you want the bot to be able to respond to messages in the same chat with itself. For example, if the bot's number is 0000, it will be able to send and receive messages to/from 0000.
both:
This option allows both the bot and you (the developer/administrator) to intervene in the chat of a person interacting with the bot.
none:
(default option) Only allows interaction between the user and the bot, without intervention from the host number.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([
...
])
const
adapterProvider
=
createProvider
(BaileysProvider
,
{
writeMyself
:
'host'
as
'none'
|
'host'
|
'both'
})
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de events.txt ---
Events - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Default
WELCOME
Received Image or Video
MEDIA
Received Document
DOCUMENT
Received Location
LOCATION
Received Voice Note
VOICE_NOTE
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Events
Sometimes users send messages such as an image, a video or special location messages, among others, to receive and start a conversation when a message of this type arrives we can use the events.
WELCOME
Default
When a user sends a "text" message that does not exist in a keyword on another flow, the WELCOME event will be triggered by default, which is the default event.
Let's imagine the case in which a person writes the word
Thank you!
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAnswer
(
'Ey welcome?'
)
const
greetingFlow
=
addKeyword
([
'hello'
,
'hi'
])
.addAnswer
(
'Hi!'
)
Copy
Copied!
We can see in the diagram above that the bot does a search in all the flows to get the best flow that can respond to the keyword "Thank You" but as it does not find then the "WELCOME" is triggered.
MEDIA
Received Image or Video
When a user sends an image or a video, the MEDIA event, which is the default event, will be triggered by default. This is ideal for when we need them to send information and we need to store it.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
mediaFlow
=
addKeyword
(
EVENTS
.
MEDIA
)
.addAnswer
(
'I received a media image/video'
)
Copy
Copied!
To save the media file you must invoke the saveFile function from the provider you are using.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
mediaFlow
=
addKeyword
<
BaileysProvider
>(
EVENTS
.
MEDIA
)
.addAnswer
(
'I received a media image/video'
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
DOCUMENT
Received Document
When a user sends a document, DOCUMENT event will be triggered by default, which is the default event.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
documentFlow
=
addKeyword
(
EVENTS
.
DOCUMENT
)
.addAnswer
(
"Wow! I'm sorry I can't read this document right now"
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
LOCATION
Received Location
Location must be sent via WhatsApp, does not yet allow location links from external apps
When your chatbot needs to access a user's location, it's important to ensure that the location is sent directly from the WhatsApp app to have results. Once the location is received, you can perform a console log of ctx to view the details of the received location.
The received location context will look something like this in console:
ctx:
{
...
message:
Message
{
locationMessage:
LocationMessage
{
degreesLatitude:
-2.1462137699127197,
degreesLongitude:
-79.88981628417969,
name:
'Doctor Miguel Angel Jijón Teran'
,
address:
'Doctor Miguel Angel Jijón Teran, Guayaquil, Ecuador'
,
},
},
body:
'_event_location__0d5c9f57-0909-44a1-995f-902f9df3b21f'
,
name:
'yeyodev 👨🏾‍💻'
,
from:
'593000000000'
}
Copy
Copied!
This will output the user's latitude and longitude in the console, allowing you to effectively utilize the location data for your chatbot's functionality.
To access the location data, you can use the following approach:
location.flow.ts
location.flow.js
import
{ EVENTS
,
addKeyword }
from
"@builderbot/bot"
;
export
default
addKeyword
(
EVENTS
.
LOCATION
)
.addAnswer
(
"I have received your location!"
,
null
,
async
(ctx)
=>
{
const
userLatitude
=
ctx
.
message
.
locationMessage
.degreesLatitude;
const
userLongitude
=
ctx
.
message
.
locationMessage
.degreesLongitude;
})
Copy
Copied!
VOICE_NOTE
Received Voice Note
When a user sends a voice note, the VOICE_NOTE event will be triggered by default, which is the event intended for this behavior, it is important to understand that a voice note is different from an image or video file.
app.ts
app.js
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
const
voiceNoteFlow
=
addKeyword
(
EVENTS
.
VOICE_NOTE
)
.addAnswer
(
'Give me a second to hear you!'
,
async
(ctx
,
{ provider })
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{path
:
'...'
})
//console.log(localPath)
})
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de inicio.txt ---
BuilderBot.app Create a WhatsApp Chatbot, Without Limit
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Get started with BuilderBot
This is a
free
and open source framework with an intuitive and extensible way to create chatbot and smart apps that connect to different communication channels like
Whatsapp
,
Telegram
and others.
We have made an intuitive framework so you can have your first chatbot in minutes.
Winner of the first prize at OpenExpo 2024
🏆
Quick Start
To create quickly with the following command
pnpm
npm
pnpm
create
builderbot@latest
Copy
Copied!
Installation and requirements
⚡ Building an AI bot
In this few minutes tutorial you can have your own chatbot with whatsapp and artificial intelligence to talk about your business.
Learn how to create a bot with the new open ai assistants
Code repository
Quick Example
In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are:
info, hello, hi
. You can see how to create the bot and implement the
flows
.
main.ts
main.js
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
3000
)
adapterProvider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de methods.txt ---
Methods - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
State
GlobalState
FlowDynamic
FallBack
EndFlow
GotoFlow
Blacklist
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Methods
Inside each addAction or addAnswer we can execute logic and we can make use of some methods that will facilitate the development.
State
In many occasions you will need to share data between flows and no matter if you have modularized your project in different files you can use state in the callback function to be able to access the individual state of each user.
Let's imagine the case where you have two flows.
Flow A: In charge of collecting user data.
Flow B: Responsible for generating a record in the database.
but both flows are independent files
Remember
that the state is independent per conversation between user and bot.
app.ts
flow-a.ts
flow-b.ts
import
{ createFlow
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
;
// ...
import
flowA
from
'./flows/flow-a'
import
flowB
from
'./flows/flow-b'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([flowA
,
flowB])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
Copy
Copied!
Each conversation history with the user is totally independent, in this way we avoid mixing conversations.
It is important to understand that the state is volatile, it does not permeate anywhere. If you are worried about the performance level, you can see it
here
, but I'll save you time by telling you that it is a
Map
GlobalState
Very similar to
state
there is another method called GlobalState to share a global state of the bot between different flows. The main use for this method is to share data that can change and that every conversation between bot and user can access.
Below you can see a practical example where we use the globalState to use it as a switch to allow or disallow the bot to respond no matter who writes to it.
app.ts
flow-on-off.ts
flow-welcome.ts
import
{ createFlow
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
;
// ...
import
flowWelcome
from
'./flows/flow-welcome'
import
flowOnOff
from
'./flows/flow-on-off'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([flowWelcome
,
flowOnOff])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
Copy
Copied!
State/GlobalState Options
Both methods such as state and global state contain similar options and funcinalides, which depending on the use case can be very useful.
Clear
This method allows the state to be cleaned either globally or independently. It technically clears the Map.
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.clear
()
})
.addAction
(
async
(_
,
{ globalState })
=>
{
globalState
.clear
()
})
Copy
Copied!
Update
To add or update a value in the state we have available the update method. This method receives an object which if the value does not exist creates it and returns a new object with all the values.
It is important to understand that it is a promise to avoid rare behavior by adding the
await
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
await
state
.update
({name
:
'Joe'
,
age
:
'33'
})
await
state
.update
({email
:
'test@test.com'
})
})
.addAction
(
async
(_
,
{ globalState })
=>
{
await
globalState
.update
({name
:
'Joe'
,
age
:
'33'
})
await
globalState
.update
({email
:
'test@test.com'
})
})
Copy
Copied!
Get
When we need to retrieve the state values we can do it individually by calling by the property name as follows.
Available in:
state
,
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.get
(
'propertyName'
)
})
.addAction
(
async
(_
,
{ globalState })
=>
{
globalState
.get
(
'propertyName'
)
})
Copy
Copied!
GetMyState
Another way to retrieve the entire state object belonging to a user-independent conversation is by using getMyState
Available in:
state
.addAnswer
(
'..'
,
null
,
async
(_
,
{ state })
=>
{
state
.getMyState
()
})
Copy
Copied!
GetAllState
When we are working with the globalState and we want to retrieve all the properties object with their respective values you can use getAllState
Available in:
globalState
.addAnswer
(
'..'
,
null
,
async
(_
,
{ globalState })
=>
{
globalState
.getAllState
()
})
Copy
Copied!
FlowDynamic
Many times you will need to send messages coming from an API call or dynamic data from data base or from processes. In this case you should use
flowDynamic
.
flow-standalone.ts
flow-multiline.ts
flow-list.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowStandAlone
=
addKeyword
(
'register'
)
.addAnswer
(
'What is your name?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
const
responseName
=
ctx
.body
//.... db.insert({name:responseName})
await
flowDynamic
(
`Thanks for register
${
responseName
}
`
)
})
export
default
flowStandAlone
Copy
Copied!
It is NOT recommended to send many messages in a row because the
provider
may determine that it is spam.
If you want to send a list of products it is recommended to send a few products between 4 to 8 and you can ask the user what category of products and other details to filter and be able to respond with the ideal product list.
FlowDynamic Options
Name
body
Type
string
Description
You can send a message inside an object using the body property. It is ideal when you need to send a message apart from the message to send a media or to place a delay.
Name
delay
Type
number
Description
This is the number of milliseconds that will elapse before the message is sent.
Name
media
Type
string
Description
The url or local path of the file to send, must be a text string and if it is a URL it must be public.
const
flow
=
addKeyword
(
'register'
)
.addAction
(
async
(_
,
{ flowDynamic })
=>
{
await
flowDynamic
([{ body
:
`Thanks
${
responseName
}
`
}])
await
flowDynamic
([{
body
:
`message with 2 seconds delay`
,
delay
:
2000
}])
await
flowDynamic
([{
body
:
`Look at this`
,
media
:
`https://i.imgur.com/0HpzsEm.png`
}])
await
flowDynamic
([{
body
:
`Look at this`
,
media
:
join
(
'assets'
,
'file.pdf'
)
}])
})
Copy
Copied!
FallBack
The fallBack() function is a fundamental resource within a bot's interaction flow, used to handle invalid or unexpected responses from the user. When a user provides a message that does not match any keyword or expected response, the bot can invoke the fallBack() function to repeat the last message and wait for a valid response.
To integrate the fallBack() function into the bot interaction flow, it is used within the
addAnswer()
or
addAction()
method. Within this method, a condition is set that verifies whether the user's response is valid or not. In case the response does not meet the expected criteria, fallBack() is called to repeat the last message and request a valid response. For example:
flow-validate-email-custom-error.ts
flow-validate-email-default-error.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowEmailRegister
=
addKeyword
(
'hello'
)
.addAnswer
(
'What is your email?'
,
{capture
:
true
}
,
(ctx
,
{ fallBack })
=>
{
if
(
!
ctx
.
body
.includes
(
'@'
)) {
return
fallBack
(
`Ups! is not a valid email`
);
}
else
{
// db.insert({email:ctx.body})
}
});
Copy
Copied!
EndFlow
The endFlow function is used in chat applications or conversational user interfaces to end a flow of interaction with the user. Imagine a scenario where you are collecting information from a user in several steps, such as their name, email address and phone number, and at each step the user has the option to cancel the current operation.
By using endFlow, you can provide the user with an easy way to cancel the transaction at any time. For example, you could present a button or command that the user can activate to indicate that they wish to stop the current process. Once endFlow is triggered, the interaction flow is terminated and a final message can be displayed to the user, informing them that the request has been canceled.
In summary, endFlow improves the user experience by providing a clear and easy-to-use exit in case they decide to abandon the process at any stage of the interaction flow. This helps ensure a smoother and more satisfying user experience in conversational applications.
flow-validate-email-custom-error.ts
const
flowRegister
=
addKeyword
([
'Hi'
])
.addAnswer
(
[
'Hello!'
,
'To submit the form I need some data...'
,
'Write your *Name*'
]
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
endFlow
,
state })
=>
{
if
(
ctx
.body
===
'cancel'
) {
return
endFlow
(
`Your request has been canceled`
);
}
await
state
.update
({name
:
ctx
.body})
return
flowDynamic
(
`Nice to meet you *
${
ctx
.body
}
*, let's continue...`
);
}
)
.addAnswer
(
[
'I also need your last names'
]
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
endFlow
,
state })
=>
{
if
(
ctx
.body
===
'cancel'
) {
return
endFlow
();
}
await
state
.update
({lastName
:
ctx
.body})
return
flowDynamic
(
`Perfect *
${
ctx
.body
}
*, finally...`
);
}
)
Copy
Copied!
GotoFlow
The
gotoFlow
function allows the smooth transition between different interaction flows in a conversational application. This method is useful when you need to separate the interaction logic into different flows and direct the user from one flow to another according to certain conditions or events.
For example, suppose that in a virtual assistant application you have one flow for registered users and another for unregistered users. With
gotoFlow
, it is possible to direct a newly registered user from the unregistered user flow to the registered user flow, or vice versa, providing a personalized and consistent experience for each type of user.
In the code provided, it is shown how to use
gotoFlow
to direct the user to the corresponding flow according to their registration status. This helps to modularize the application logic and facilitates the management of multiple conversation flows.
flow-welcome.ts
flow-a.ts
flow-b.ts
app.ts
import
{ addKeyword
,
EVENTS }
from
'@builderbot/bot'
;
const
flowWelcome
=
addKeyword
(
'hi'
)
.addAnswer
(
'Welcome!'
,
null
,
async
(ctx
,
{ gotoFlow })
=>
{
// db.get(...)
const
userRegistered
=
true
;
if
(userRegistered)
return
gotoFlow
(flowRegistered);
return
gotoFlow
(flowUserNotRegistered);
});
export
default
flowWelcome
Copy
Copied!
It is important to note that the implementation of gotoFlow must have a return before
Blacklist
Many times we will need to add or manage a list of nuemers that we do not want to interact with our bot. For them there is a blacklist that contains a series of methods to add, remove and review numbers.
Imagine a case where you want to talk to a contact without the intervention of the bot. You could use this mechanism
flow-mute.ts
flow-check-if.ts
import
{ addKeyword }
from
'@builderbot/bot'
;
const
flowMute
=
addKeyword
(
'hi'
)
.addAction
(
async
(ctx
,
{ flowDynamic
,
blacklist })
=>
{
// const dataFromDb = db.findOne({from:ctx.from}) simualte db query
const
dataFromDb
=
{muted
:
true
}
if
(
dataFromDb
.muted) {
blacklist
.add
(
ctx
.from)
await
flowDynamic
(
`
${
ctx
.from
}
! added to blacklist`
);
}
else
{
blacklist
.remove
(
ctx
.from)
await
flowDynamic
(
`
${
ctx
.from
}
! removed from blacklist`
);
}
});
export
default
flowMute
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de plugins.txt ---
CONTRIBUTING - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
CONTRIBUTING
Welcome
We're glad that you're interested in contributing to our project! Here you will find all the necessary information to start collaborating. You can contribute in various ways, whether it's updating the documentation, improving the code, reviewing pending issues in the
issues
, or even making financial contributions, which will be used for various purposes related to the development and maintenance of the project. You can see more details on how to make financial contributions
here
.
The main language we use in this project is TypeScript, which allows us to maintain readable and scalable code.
Frequent Questions
Here are some answers to frequently asked questions that may arise when contributing to the project:
What is Lerna?
You can find an explanation in this
video
.
How do I make commits effectively?
Here's a
video
that shows you how to do it.
What are our communication channels?
You can join our community on
Discord
.
Requirements:
Before starting to contribute to the project, make sure you have the following tools installed:
Node.js
: Version 18 or higher. You can download Node from
here
.
pnpm
: Package manager. You can install it by following the instructions
here
.
VSCode
: Code editor that we recommend, as it has useful plugins.
Conventional Commits
: VSCode plugin that helps you create semantic commits, following best practices. You can install it from
here
.
Get Starter
Make a fork
Before starting work on the project, fork it to your own GitHub account. This will allow you to work on your own copy of the repository. Click on the following link to fork:
here
.
Clone the Repository (from your fork)
Once you have forked the project, clone your own copy of the repository using the following command in your terminal:
git
clone
https://github.com/TU_USERNAME/bot-plugins
Copy
Copied!
Dependencies install
Go to the project folder and run the following commands to install the necessary dependencies:
cd
bot-plugins
pnpm
install
pnpm
run
build
Copy
Copied!
Create a new integration
To create a new integration, run the following command in your terminal:
pnpm
run
create.package
<
package_nam
e
>
Copy
Copied!
compile (build)
To compile the application, run the following command in your terminal. This will generate a dist directory within the monorepo packages.
npx
lerna
run
build
--scope=
<
package_name
>
Copy
Copied!
tests environments
Once you have run the build and everything is correct, run the following command in your terminal:
pnpm
run
copy.lib
Copy
Copied!
This command will copy the necessary files into the base_app folder. Make sure you have previously run npm install within the
base_app
folder. Then, from the root of your directory, run:
pnpm
run
copy.lib
Copy
Copied!
To start the assistant, run:
npm
run
dev
Copy
Copied!
It should work smoothly.
Test End-to-End (E2E)
All changes made must pass the
end-to-end
tests. These tests are run with the following command:
pnpm
run
test
Copy
Copied!
Make sure you have a test folder and files with the
.test.ts
extension for your
tests
.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de plugins_agents.txt ---
OpenAi Plugin - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Install
Langchain
Sign in
OpenAi Plugin
Before you start, you must make sure to have an API key from
OpenAI
Install
Install the library to make use of OpenAI:
npm
npm
install
@builderbot-plugins/openai-agents
Copy
Copied!
import
"dotenv/config"
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS } =
from
"@builderbot/bot"
;
import
BaileysProvider
from
"@builderbot/provider/baileys"
;
import
MockAdapter
from
"@builderbot/database/mock"
;
/** ... other flows importations */
import
{ EmployeesClass }
from
"@builderbot-plugins/openai-agents"
;
/**
* PLugin Configuration
*/
const
emplyeeInstace
=
new
EmployeesClass
({
apiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
model
:
"gpt-3.5-turbo-16k"
,
temperature
:
0
})
emplyeeInstace
.employees
([
{
name
:
"SALES_AGENT"
,
// NAME OF YOUR AGENT
description
:
// DESCRIPTION OF YOUR AGENT AND WHAT IT WILL DO
"I'm Rob, the friendly salesperson in charge of assisting you if you intend to buy or are interested in any product. My responses are brief."
,
flow
:
YOUR_FLOW_HERE
,
// YOUR FLOW IMPLEMENTATION
}
,
{
name
:
"EXPERT_AGENT"
,
description
:
"Hello, my name is Leifer. I am the specialized person in charge of resolving your doubts about our chatbot course, which is developed with Node.js and JavaScript. This course is designed to facilitate sales automation in your business. I will provide concise and direct answers to maximize your understanding."
flow: expertoFlow
,
}
])
/**
* ENTRY POINT!
* THIS NOT USE AI FOR MANAGE EVENTS
* WELCOME FLOW OR FIRTS FLOW
*/
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx
,
ctxFn)
=>
{
const
{
state
}
=
ctxFn
const
pluginAi
=
ctxFn
.
extensions
.employeesAddon
/** This function is the one that does the job */
/** Determine the flow and retrieva an employee object */
const
employeeDeterminated
=
await
pluginAi
.determine
(
ctx
.body)
if
(
!
employeeDeterminated
?.employee){
return
ctxFn
.flowDynamic
(
"Oops, I'm sorry, I don't understand. How can I help you?"
)
}
state
.update
({answer
:
employeeDeterminated
.answer})
pluginAi
.gotoFlow
(
employeeDeterminated
.employee
,
ctxFn)
})
const
expertFlow
=
addKeyword
(
EVENTS
.
ACTION
)
.addAction
(
async
(_
,
{state
,
flowDynamic})
=>
{
const
currentState
=
state
.getMyState
()
return
flowDynamic
(
currentState
.answer)
/** here come the answer by OpenAi pluggin */
})
// ----- INITIALIZE
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
();
const
adapterFlow
=
createFlow
([
welcomeFlow
,
expertFlow
/** ... other flows */
]);
const
adapterProvider
=
createProvider
(BaileysProvider);
const
configBot
=
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
const
configExtra
=
{
extensions
:
{
employeesAddon
:
emplyeeInstace
}
}
await
createBot
(configBot
,
configExtra);
};
main
();
Copy
Copied!
REFERENCES:
OpenAi-Agents
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de plugins_langchain.txt ---
Builderbot x Langchain - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Builderbot x Langchain
pnpm
pnpm
install
@builderbot-plugins/langchain
Copy
Copied!
This is a series of utilities that use AI based on the langchain framework
each class returns an addkeyword like the one we know, with 3 important methods
setKeyword
create a new addkeyword
setAIModel
create a model based on openai or gemini
create
create a new flow
each flow update the state and save the response that you expected user like
await state.update({  })
routingFlow.ts
structuredFlow.ts
aiFlow.ts
import
"dotenv/config"
import
{ EVENTS
,
MemoryDB
,
createBot
,
createFlow
,
createProvider }
from
"@builderbot/bot"
import
{ TelegramProvider }
from
"@builderbot-plugins/telegram"
import
{ createFlowRouting
,
structuredOutput }
from
"src"
import
z
from
"zod"
const
welcome
=
createFlowRouting
.setKeyword
(
EVENTS
.
WELCOME
)
.setIntentions
({
intentions
:
[
'greeting'
,
'closure'
]
,
description
:
`GREETING: if the user greets\nCLOSURE: if the user says goodbye or thanks for anything`
})
.setAIModel
({ modelName
:
'gemini'
})
.create
({
afterEnd
(flow) {
return
flow
.addAction
((_
,
{ state })
=>
{
console
.log
(
state
.get
(
'intention'
))
state
.clear
()
})
}
,
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(TelegramProvider)
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([welcome])
})
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de plugins_shopify.txt ---
Shopify - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Install
SmartFlows
NormalFlows
Tests
Accuracy
References
Agents
Langchain
Sign in
Shopify
If you need help to generate your Shopify API key you can visit these resources
Shopify Api Key
To integrate the plugin into your other flows, you need to install the library:
Install
npm
npm
install
@builderbot-plugins/shopify
Copy
Copied!
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider
,
createFlow }
from
'@builderbot/bot'
import
{ createShopifyFlow }
from
'@builderbot-plugins/shopify'
import
BaileysProvider
from
"@builderbot/provider/baileys"
;
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
})
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flow)
})
}
main
()
Copy
Copied!
SmartFlows
Okay, a smartflow is nothing more than a flow like we know, it's just that this one has something that makes it special!
That something is the ability to communicate with AI to understand what the user is trying to tell us.
To add a smartflow, follow the code I show you below
/* stuff code */
const
byeFlow
=
addKeyword
(
'bye'
)
.addAnswer
(
'bye, i hope see you soon'
);
const
smartFlowBye
=
{
name
:
'BYE_FLOW'
,
description
:
[
"I'm an expert in goodbyes,"
,
"I'm the right person to respond when the user says bye or is saying goodbye."
]
.join
(
' '
)
,
flow
:
byeFlow
}
const
extra
=
{
flows
:
[smartFlowBye]
}
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
,
}
,
extra)
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flows)
})
Copy
Copied!
The bot's response should be something like this.
NormalFlows
Sometimes we just need a common flow to provide immediate and controlled responses. In this case, let's simply add the flow to trigger an action when the user says thank you.
const
gratefullFlow
=
addKeyword
(
'/thanks/'
,
{ sensitive
:
false
,
regex
:
true
})
.addAnswer
(
"Thank you for trusting our store ❤️"
);
const
flows
=
flow
.concat
(gratefullFlow)
const
{
flow
}
=
await
createShopifyFlow
({
modelName
:
'gpt-3.5-turbo-16k'
,
openApiKey
:
"YOUR_OPEN_API_KEY_HERE"
,
shopifyApiKey
:
"YOUR_SHOPIFY_API_KEY_HERE"
,
shopifyDomain
:
"YOUR_SHOPIFY_DOMAIN_HERE"
})
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
(flows)
})
Copy
Copied!
Tests
Some tests done in the plugin can be found at the following link.
The following tests were conducted in various real-life scenarios, ranging from unfamiliarity to ambiguity
Tests
Accuracy
ACCURACY FROM PLUGIN
The plugin was subjected to various conversational tests, ranging from direct questions to more conversational ones.
here somethings examples
The plugin has a 97% of preccision when the conversation is not ambiguous
The plugin has a 96% accuracy when the conversation is unambiguous. This means it is as accurate as the question itself.
This does not diminish its potential.
TODO:
Improve history conversation.
Manage ambiguous question in same flow.
Improve answer triguers by agents.
Dynamic language spoken by the user.
References
REFERENCE:
Shopify pluggin
Telegram provider
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de plugins_telegram.txt ---
Telegram - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Install
Shopify
Agents
Langchain
Sign in
Telegram
Create your first Telegram bot if you don't have one yet
create your firts Telegram bot
Implementing a new communication channel such as telegram without affecting the logic of your project is very simple. Below you can find the starting point to implement the new telegram provider.
Install
pnpm
npm
pnpm
install
@builderbot-plugins/telegram
Copy
Copied!
import
{ createBot
,
MemoryDB
,
createProvider
,
addKeyword
,
createFlow }
from
'@builderbot/bot'
import
{ TelegramProvider }
from
'@builderbot-plugins/telegram'
const
welcomeFlow
=
addKeyword
([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
'Your name is?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
([
`nice!
${
ctx
.body
}
`
,
'I will send you a funny image'
])
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
dataApi
=
await
fetch
(
`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`
)
const
[
imageUrl
]
=
await
dataApi
.json
()
await
flowDynamic
([{body
:
'😜'
,
media
:
imageUrl}])
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(TelegramProvider
,
{
token
:
'YOUR_TELEGRAM_TOKEN_HERE'
})
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
In this way we have already implemented a new provider for Telegram keeping the same logic.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers.txt ---
Providers - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Providers
Providers are in charge of providing the communication bridge between your bot and
whatsapp
,
telegram
or custom provider.
You can change your provider very easily without affecting the logic of your bot.
It is as simple as implementing the connector of the provider of your choice. At the moment we have integrations with more than four suppliers.
Whatsapp:
Meta
,
Twilio
,
Baileys
,
WPPConnect
,
Venom
,
Telegram
,
Custom Provider
Each provider may need to adjust access keys, settings, among other properties that are usually passed as an object in the
createProvider
function.
meta-provider.ts
twilio-provider.ts
baileys-provider.ts
venom-provider.ts
wppconnect-provider.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ MetaProvider }
from
'@builderbot/provider-meta'
;
export
type
IProvider
=
typeof
MetaProvider
export
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
'jwtToken'
,
numberId
:
'numberId'
,
verifyToken
:
'verifyToken'
,
version
:
'v16.0'
,
})
Copy
Copied!
Below you will find more information about each of these providers.
Meta
The
WhatsApp Business Platform
enables medium and large businesses to communicate with their customers on a large scale. You can initiate conversations with customers in just minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through the channel of their choice.
meta-provider.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ MetaProvider }
from
'@builderbot/provider-meta'
;
export
type
IProvider
=
typeof
MetaProvider
export
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
'jwtToken'
,
numberId
:
'numberId'
,
verifyToken
:
'verifyToken'
,
version
:
'v16.0'
,
})
Copy
Copied!
More info about Meta provider
Twilio
Twilio
is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communications APIs enable businesses to provide the right communication experience for their customers within web and mobile applications. By using Twilio APIs, developers can quickly add this functionality to an application, such as voice messaging, video calls, text messaging and more.
twilio-provider.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ TwilioProvider }
from
'@builderbot/provider-twilio'
;
export
type
IProvider
=
typeof
TwilioProvider
export
const
adapterProvider
=
createProvider
(TwilioProvider
,
{
accountSid
:
'YOUR_ACCOUNT_SID'
,
authToken
:
'YOUR_ACCOUNT_TOKEN'
,
vendorNumber
:
'+14155238886'
,
publicUrl
:
"public_url"
,
//optional
});
Copy
Copied!
More info about Twilio provider
Baileys
Baileys
is an open source project which allows sending messages, receiving messages and dozens of other features by implementing WebSocket in a version of whatsapp.
It is a project with great trajectory driven by people with great knowledge of the subject, you can deepen in this library directly in its documentation or
repository
.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
If you want to see more examples taking full advantage of this provider in conjunction with the builderbot library you can check this
@jorgechavarriaga
repository
baileys-provider.ts
baileys-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
;
export
type
IProvider
=
typeof
BaileysProvider
export
const
adapterProvider
=
createProvider
(BaileysProvider)
Copy
Copied!
Venom
Venom
is an open-source project that utilizes JavaScript to create high-performance bots for WhatsApp. It supports a wide range of interactions including customer care, media sending, AI-based phrase recognition, and various architectural designs tailored for WhatsApp.
You can visit their
official
website as the repository to understand other features you can use.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
venom-provider.ts
venom-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ VenomProvider }
from
'@builderbot/provider-venom'
;
export
type
IProvider
=
typeof
VenomProvider
export
const
adapterProvider
=
createProvider
(VenomProvider)
Copy
Copied!
WPPConnect
WPPConnect
is an open source project developed by the JavaScript community with the aim of exporting functions from WhatsApp Web to the node, which can be used to support the creation of any interaction, such as customer service, media sending, intelligence recognition based on phrases artificial and many other things, use your imagination
You can visit their official website as the
repository
to understand other features you can use.
Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in.
wppconnect-provider.ts
wppconnect-provider-extend.ts
app.ts
import
{ createProvider }
from
"@builderbot/bot"
;
import
{ WPPConnectProvider }
from
'@builderbot/provider-wppconnect'
;
export
type
IProvider
=
typeof
WPPConnectProvider
export
const
adapterProvider
=
createProvider
(WPPConnectProvider)
Copy
Copied!
Wali.chat Provider
Custom Provider
Custom provider there is the possibility to build your own customized adapter, we know that there are many more providers that can be very useful, an example can be
Wali.chat
which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize and share data with your agents.
app.ts
provider/wali.ts
provider/wali.events.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ WaliProvider
as
Provider }
from
'./provider/wali'
const
PORT
=
process
.
env
.
PORT
??
3008
const
fullSamplesFlow
=
addKeyword
<
Provider
,
Database
>([
'samples'
,
utils
.setEvent
(
'SAMPLES'
)])
.addAnswer
(
`💪 I'll send you a lot files...`
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTJ0ZGdjd2syeXAwMjQ4aWdkcW04OWlqcXI3Ynh1ODkwZ25zZWZ1dCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/LCohAb657pSdHv0Q5h/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([fullSamplesFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
token
:
process
.
env
.
TOKEN
,
deviceId
:
process
.
env
.
DEVICE_ID
})
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_baileys.txt ---
Baileys Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
QR Code
Pairing code
Send Presence Update
Number Exists on WhatsApp
Profile Picture
Modifying Chats
Improve performance with Baileys
More examples
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Baileys Provider
The
Baileys
library originated as a project for CS-2362 at
Ashoka University
and is not affiliated
with or endorsed by WhatsApp. Use it at your own discretion and avoid spamming individuals. We discourage
the use of stalkerware, bulk messaging, or any automated messaging practices.
Baileys
is a free WhatsApp provider
that operates
via WhatsApp Web. It interacts directly with WhatsApp Web using a WebSocket and does not require Selenium or any
other browser. By avoiding Selenium or Chromium, Baileys conserves significant RAM resources.
Avoid using buttons and lists as they are not fully compatible. While they may display on some devices, they often fail to function as intended.
QR Code
Link device QR Code In the code below you can see the standard way to link a device by scanning the QR code with the whatsapp application.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Pairing code
Link device pairing code, In the code below you can see the alternative way to link the whatsapp account through a pairing code.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Send Presence Update
The method
sendPresenceUpdate
lets the person/group with id know whether you're online, offline, typing etc.
This method has the following signature:
(property) sendPresenceUpdate
:
(type
:
WAPresence
,
toJid
?:
string
)
=>
Promise
<void>
Copy
Copied!
WAPresence can be one of the following:
type
WAPresence
=
'unavailable'
|
'available'
|
'composing'
|
'recording'
|
'paused'
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms)
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Sending Presence Update*`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
await
flowDynamic
(
'This is an example of presence update'
)
await
provider
.
vendor
.sendPresenceUpdate
(
'recording'
,
ctx
.
key
.remoteJid)
await
waitT
(
5000
)
await
provider
.
vendor
.sendPresenceUpdate
(
'composing'
,
ctx
.
key
.remoteJid)
await
waitT
(
5000
)
await
flowDynamic
(
'Great!'
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Video Send Presence Update
Number Exists on WhatsApp
To check if an entered number exists on WhatsApp, you use the
onWhatsApp
method of the provider.
This method has the following signature:
onWhatsApp
:
(
...
jids
:
string
[])
=>
Promise
<{
exists
:
boolean
;
jid
:
string
;
}[]>
Copy
Copied!
This method accepts one or more phone numbers (JIDs) as arguments and returns a promise that resolves to an array of objects containing
the existence status (exists) and JID (jid) for each number.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Number Exist on Whatsapp*`
)
.addAnswer
(
'*Enter the number to check:*'
,
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
checkNumber
=
ctx
.body
try
{
const
onWhats
=
await
provider
.
vendor
.onWhatsApp
(checkNumber)
if
(onWhats[
0
]?.exists) {
await
flowDynamic
([
`*Exists:*
${
onWhats[
0
].exists
}
\n*JID:*
${
onWhats[
0
].jid
}
`
,
`*Object:*
${
JSON
.stringify
(onWhats
,
null
,
6
)
}
`
])
}
else
{
await
flowDynamic
(
`The number *
${
checkNumber
}
* does not exists on Whatsapp.`
)
}
}
catch
(error) {
await
flowDynamic
(
`*Error:*
${
error
}
`
);
}
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Profile Picture
The method
profilePictureUrl
allows us to retrieve the profile picture of a given number.
This method has the following signature:
(property) profilePictureUrl
:
(jid
:
string
,
type
?:
"image"
|
"preview"
,
timeoutMs
?:
number
)
=>
Promise
<
string
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *profile Picture*`
)
.addAnswer
(
'Enter number to check image profile: '
,
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic
,
fallBack
,
endFlow })
=>
{
const
check
=
ctx
.body
+
'@s.whatsapp.net'
try
{
const
imageProfile
=
await
provider
.
vendor
.profilePictureUrl
(
check
.replace
(
/\+/
g
,
''
)
,
'image'
,
10000
)
await
flowDynamic
([
{
body
:
'*Profile Picture:*'
,
media
:
imageProfile
}
])
return
endFlow
(
'End.'
)
}
catch
(error) {
await
flowDynamic
(
`Error:
${
error
.message
}
`
)
return
fallBack
(
'Try it again.'
)
}
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Modifying Chats
The chatModify method provides various options to modify a chat, including:
Archive a chat
Mute/unmute a chat
Mark a chat read/unread
Delete a message for me
Delete a chat
Pin/unpin a chat
Star/unstar a message
This method has the following signature:
(property) chatModify: (mod: ChatModification, jid: string) => Promise
Copy
Copied!
Delete a message for me
when the received message does not comply with my business logic rules. (Develop your own logic rules)
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
badWords
=
[
'fuck'
,
'ass hole'
,
'motherfucker'
]
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms);
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Delete User Message:*`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
resp
=
ctx
.
body
.toLocaleLowerCase
()
const
containsBadWord
=
badWords
.some
(word
=>
resp
.includes
(word))
const
id
=
ctx
.
key
.id
const
fromMe
=
ctx
.
key
.fromMe
const
timeStamp
=
ctx
.messageTimestamp
if
(containsBadWord) {
await
flowDynamic
(
'Your message is going to be deleted as you are sending inappropriate language.'
)
await
waitT
(
3500
)
try
{
await
provider
.
vendor
.chatModify
(
{ clear
:
{ messages
:
[{ id
:
id
,
fromMe
:
fromMe
,
timestamp
:
timeStamp }] } }
,
ctx
.
key
.remoteJid
)
await
flowDynamic
(
`Message deleted successfully.`
)
}
catch
(error) {
await
flowDynamic
(
`Error:
${
JSON
.stringify
(error
,
null
,
3
)
}
`
)
}
}
await
flowDynamic
(
'Welcome!'
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Delete user message
Improve performance with Baileys
Baileys is a powerful provider for WhatsApp, but its ability to listen and process a wide range of events in real-time can lead to significant resource consumption, especially for highly active accounts. This guide will help you optimize your builderbot.app bot's performance when using Baileys as a provider.
Quickly optimize your Baileys provider
Activate these options in your Baileys provider configuration to improve performance:
const
adapterProvider
=
createProvider
(Provider
,
{
experimentalStore
:
true
,
// Significantly reduces resource consumption
timeRelease
:
10800000
,
// Cleans up data every 3 hours (in milliseconds)
})
Copy
Copied!
In addition to this configuration I recommend a reboot every 12 or 24 hours depending on how active your bot is. You can follow this guide to
configure the restarts
Benefits:
experimentalStore: true
: Limits processing to individual messages only, drastically reducing resource usage.
timeRelease: 10800000
: Performs periodic cleanups of accumulated data every 3 hours.
Note
:
experimentalStore
may limit some advanced WhatsApp functionalities, especially for groups.
Types of monitored events
Baileys constantly monitors various types of events, including:
Individual messages
: Sending and receiving messages in one-on-one chats.
Group messages
: All activity in WhatsApp groups.
Read states
: Updates when messages are read.
Contact stories
: Posting and viewing of statuses/stories.
Message editing and deletion
: Changes to existing messages.
Reactions
: Emojis and other reactions to messages.
Profile updates
: Changes in profile pictures, statuses, etc.
Calls
: Notifications of incoming and outgoing calls.
Impact on resources
Constant processing
: Each event triggers processes in the bot, consuming CPU.
Data storage
: Events are recorded in "baileys_store.json", increasing storage usage.
Frequent overwriting
: The file is updated with each new event, which can be I/O intensive.
Exponential growth
: In very active accounts, the volume of events can grow rapidly.
Optimization strategies
1. Using ExperimentalStore
The
experimentalStore: true
option is an advanced feature in builderbot.app designed to significantly optimize the bot's resource usage.
How it works:
Limits listening and processing to only individual message events.
Drastically reduces resource consumption by ignoring other types of events.
Implementation:
const
adapterProvider
=
createProvider
(Provider
,
{
experimentalStore
:
true
,
timeRelease
:
10800000
,
// 3 hours in milliseconds
})
Copy
Copied!
Important limitations:
Only for individual messages
: Works exclusively with "message" type events for individual chats.
Not compatible with group functions
: Not suitable for bots requiring group functionalities.
Feature restriction
: Some advanced WhatsApp features may not work correctly.
2. Event filtering
Configure Baileys to ignore non-essential events for your bot. This can be done through provider configuration or by selectively handling events in your code.
3. Periodic cleanup
Use the
timeRelease
option or scheduled restarts to clear accumulated data. This helps keep the storage file size under control.
4. Selective monitoring
If possible, limit the number of chats or groups actively monitored. This can significantly reduce the number of processed events.
Implementation example
Here's an example of how to implement these strategies in your bot:
This example uses
experimentalStore
and
timeRelease
to optimize the bot's performance.
app.ts
app-experimental.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
timeRelease
:
10800000
,
// 3 hours in milliseconds
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
More examples
If you want to see more examples applying Baiely's functions you can check the links below
Delete Bot Message
Delete an existing message in the conversation
Blocked Users on Bot
Block Whatsapp user using the provider
Fetch Status
Retrieve all whatsapp profile status information
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_baileys_blocked-users.txt ---
Blocked Users on BOT - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Blocked Users on BOT
To check the blocked users on the BOT, you should use the 'fetchBlocklist()' method of the provider.
This method has the following signature:
(property) fetchBlocklist
:
()
=>
Promise
<
string[]
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *List Blocked Users on BOT:*`
)
.addAction
(
async
(_
,
{ provider
,
flowDynamic })
=>
{
const
blocked
=
await
provider
.
vendor
.fetchBlocklist
()
const
result
=
blocked
.map
((id
,
index)
=>
`id
${
index
+
1
}
:
${
id
}
`
)
.join
(
'\n'
);
await
flowDynamic
(
`*Blocked:*\n
${
result
}
`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_baileys_delete-bot-message.txt ---
Delete Bot Message - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Delete Bot Message
We can use the
sendMessage
method to delete a message sent by the bot. This method has the following signature:
(property) sendMessage
:
(jid
:
string
,
content
:
AnyMessageContent
,
options
?:
MiscMessageGenerationOptions
)
=>
Promise
<
proto
.WebMessageInfo
>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
waitT
=
(ms
:
number
)
=>
{
return
new
Promise
((resolve)
=>
{
setTimeout
(()
=>
{
resolve
(ms)
}
,
ms)
})
}
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example delete Message`
)
.addAction
(
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
number
=
ctx
.
key
.remoteJid
await
provider
.
vendor
.sendMessage
(number
,
{ text
:
`Next message is going to be deleted in 5 seconds.\n\n*
${
Date
()
}
*`
})
const
msg
=
await
provider
.
vendor
.sendMessage
(number
,
{ text
:
`This is the message to be deleted!!! `
})
await
waitT
(
5000
)
await
provider
.
vendor
.sendMessage
(number
,
{ delete
:
msg
.key })
await
flowDynamic
(
`*
${
Date
()
}
*\n\nMessage has been deleted!`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_baileys_fetchStatus.txt ---
Fetch Status - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Fetch Status
This method has the following signature:
(property) fetchStatus
:
(jid
:
string
)
=>
Promise
<{
status
:
string
;
setAt
:
Date
;
}>
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
EVENTS }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ config }
from
'dotenv'
config
()
const
PHONE_NUMBER
=
process
.
env
.
PHONE_NUMBER
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>(
EVENTS
.
WELCOME
)
.addAnswer
(
`💡 Example *Whatsapp Status*`
)
.addAction
(
async
(_
,
{ provider
,
flowDynamic })
=>
{
const
statusInfo
=
await
provider
.
vendor
.fetchStatus
(
PHONE_NUMBER
+
'@s.whatsapp.net'
)
console
.log
(statusInfo)
await
flowDynamic
(
`*Status Info for
${
PHONE_NUMBER
}
*:\n\nStatus: *
${
statusInfo
.status
}
*\nSet At:
${
statusInfo
.setAt
}
`
)
await
flowDynamic
(
`Enter phone number to check status:`
)
}
)
.addAction
(
{ capture
:
true
}
,
async
(ctx
,
{ provider
,
flowDynamic })
=>
{
const
statusR
=
await
provider
.
vendor
.fetchStatus
(
ctx
.body
+
'@s.whatsapp.net'
)
await
flowDynamic
(
`*Status for:*
${
ctx
.body
}
\n\nStatus: *
${
statusR
.status
}
*\nSet At:
${
statusR
.setAt
}
`
)
}
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{ usePairingCode
:
true
,
phoneNumber
:
PHONE_NUMBER
})
const
adapterDB
=
new
Database
()
const
botResult
=
await
createBot
(
{
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
}
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_meta.txt ---
Meta Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Requirements
Uses Cases
Meta tutorial video
What do I do now?
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Meta Provider
The
WhatsApp Business Platform
allows medium and large businesses to communicate with their customers on a large scale. You can start conversations with customers in just a few minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through their preferred channel.
Requirements
Register a
Facebook Developers
account.
You will need to verify your business and your application with official documents, the type of which may vary depending on your country.
You will need to associate an official phone number of your business with your account that is not linked to any other WhatsApp account, either regular or Business. For testing purposes, Meta provides a free phone number.
Meta offers
1000
free customer-initiated conversations to the bot, and 250 free bot-initiated conversations to the customer. Once this limit is reached, each additional conversation will have a cost that may vary depending on your country or region.
More info about Meta Deploy
Uses Cases
If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider.
Cases such as sending
buttons
,
lists
, or
native methods
directly with Meta
More info about Meta uses cases
Meta tutorial video
If you are one of those people who prefer to watch videos, here is a short tutorial on how to implement the Meta base.
Video Meta Provider
You must create a new application. To do this, click on the
Create application
button.
On this screen, you must select
Company or Business
.
In the next step, you must enter a name for your application, also enter a contact email address and select the Test Business application.
Now, go to the WhatsApp Settings section.
This is the part where you will find the access token and you can also see the number from where WhatsApp messages are sent and to where they will be sent. As you are in the trial version, you must register the numbers to which you want to send.
On this same page, you can find the Webhook section that we will soon need to use.
In the
main file
of the bot where you are implementing the meta adapter function, you are going to place the following data:
numberId:
You can find it on the previous page.
jwtToken:
You can find it on the previous page.
VerifyToken:
You can write whatever you want, it's like a keyword.
In the example below, you can see a suggestion of how this can be done by using environment variables
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
()
const
adapterFlow
=
createFlow
([flowPrincipal])
const
adapterProvider
=
createProvider
(MetaProvider
,
{
jwtToken
:
process
.
env
.
JWTOKEN
,
//EAARBW3ZBGU0UBAACDjtQIzI8JuEa.............
numberId
:
process
.
env
.
NUMBER_ID
,
//103975305758520
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
//LO_QUE_SEA,
version
:
'v16.0'
})
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
After executing the bot, you will find a message in the console similar to the following. Where you can find the URL for your
webhook
.
$
npm
start
>
node app.js
[meta]: Add this url
"WHEN A MESSAGE COMES IN"
[meta]: POST http://localhost:3000/webhook
[meta]: More information
in
the documentation
Copy
Copied!
What do I do now?
You will notice that the bot starts an HTTP service (endpoint) that must be online on a server so that you can connect it with Meta.
Option 1:
You can test locally through a proxy tunnel server. 
Download
ngork
, a free tool that will help with this.
This generates an online URL that we can use in the
WebHook
section of Meta
Option 2:
If you have already deployed your bot on a server, you need to obtain the public IP or subdomain provided to you.
Example
if you are using
Railway
, you can go to the settings section and generate a subdomain. We would then have the
WebHook
https://base-twilio-memory-production.up.railway.app/twilio-hook
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_meta_uses-cases.txt ---
Meta Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Meta Uses Cases
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ MetaProvider
as
Provider }
from
'@builderbot/provider-meta'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'ey'
,
'test'
])
.addAnswer
(
'send files...'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
}
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
.addAnswer
(
`First Way to Send Buttons`
,
{
buttons
:
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
})
.addAction
(
async
(ctx
,
{ provider })
=>
{
await
provider
.sendButtons
(
ctx
.from
,
[
{ body
:
'Option A'
}
,
{ body
:
'Option B'
}
,
{ body
:
'Option C'
}
]
,
`Send Buttons Alternative`
)
})
.addAction
(
async
(ctx
,
{ provider })
=>
{
await
provider
.sendButtonUrl
(
ctx
.from
,
{ body
:
'View Doc'
,
url
:
'https://builderbot.vercel.app'
}
,
'Send Buttons URL'
)
})
.addAnswer
(
'Send Contact'
,
null
,
async
(ctx
,
{ provider })
=>
{
await
provider
.sendContacts
(
ctx
.from
,
[
{
name
:
{
formatted_name
:
'Leifer'
,
first_name
:
'Leifer M'
}
,
phones
:
[{
phone
:
'34000000'
,
type
:
'HOME'
,
wa_id
:
'34000000'
// (optional) makes META identify the number as an active wpp user
}]
}
])
})
.addAnswer
(
'Send Location'
,
null
,
async
(ctx
,
{ provider })
=>
{
await
provider
.sendLocation
(
ctx
.from
,
{
address
:
'CDMX Centro'
,
lat_number
:
'19.3909832'
,
long_number
:
'-99.3084209'
,
name
:
'CDMX Office'
})
})
.addAnswer
(
'Send List'
,
null
,
async
(ctx
,
{ provider })
=>
{
const
list
=
{
"header"
:
{
"type"
:
"text"
,
"text"
:
"Weekly Promotions"
}
,
"body"
:
{
"text"
:
"Discover our amazing offers!"
}
,
"footer"
:
{
"text"
:
"Visit our website for more details"
}
,
"action"
:
{
"button"
:
"See more"
,
"sections"
:
[
{
"title"
:
"Clothing"
,
"rows"
:
[
{
"id"
:
"001"
,
"title"
:
"Printed T-shirt"
,
"description"
:
"Cotton t-shirt with printed design"
}
,
{
"id"
:
"002"
,
"title"
:
"Slim-fit Jeans"
,
"description"
:
"Slim-fit denim jeans for men and women"
}
]
}
,
{
"title"
:
"Electronics"
,
"rows"
:
[
{
"id"
:
"003"
,
"title"
:
"Smartphone"
,
"description"
:
"Smartphone with HD display and high-resolution camera"
}
,
{
"id"
:
"004"
,
"title"
:
"Wireless Headphones"
,
"description"
:
"Headphones with noise cancellation and Bluetooth connectivity"
}
]
}
]
}
};
await
provider
.sendList
(
ctx
.from
,
list)
})
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
jwtToken
:
process
.
env
.
JWT_TOKEN
,
numberId
:
process
.
env
.
NUMBER_ID
,
verifyToken
:
process
.
env
.
VERIFY_TOKEN
,
version
:
'v19.0'
})
const
adapterDB
=
new
Database
()
const
{
handleCtx
,
httpServer
}
=
await
createBot
<
Provider
>({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
adapterProvider
.
server
.post
(
'/v1/samples'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
,
message
,
urlMedia
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media
:
urlMedia
??
null
})
await
bot
.
provider
.sendMessage
(number
,
message
,
{})
await
bot
.
provider
.sendButtons
(number
,
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
,
'Send Buttons API'
)
await
bot
.
provider
.sendButtonUrl
(number
,
{
body
:
'View Doc'
,
url
:
'http://builderbot.app'
}
,
'Send Buttons API CTA'
)
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
adapterProvider
.
server
.post
(
'/v1/flow'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
}
=
req
.body
await
bot
.dispatch
(
'TEST'
,
{ from
:
number
,
name
:
'bot'
})
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
There are several features that the default provider does not provide and you can create them along the way
today I want to teach you a very basic but effective, the double tick or popcorn in English
Send Double Tick
to send the double tick or double popcorn you only need the ID of each new message that arrives, simple no?
let's see a clear example of this
app.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ MetaProvider }
from
'@builderbot/provider-meta'
const
PORT
=
process
.
env
.
PORT
??
3001
const
welcome
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(ctx)
=>
{
/*
{
"messaging_product": "whatsapp",
"status": "read",
"message_id": "MESSAGE_ID"
}
*/
//all you need to add is the ID of each new message
provider
.sendMessageToApi
({
"messaging_product"
:
"whatsapp"
,
"status"
:
"read"
,
message_id
:
ctx
?.message_id
}
as
any
)
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(MetaProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([welcome])
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/register'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
name
}
=
req
.body
await
bot
.dispatch
(
'EVENT_REGISTER'
,
{ from
:
number
,
name })
return
res
.end
(
'trigger'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_twilio.txt ---
Twilio Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Send Buttons
Content Template Builder
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Provider
Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communication APIs empower businesses to provide the appropriate communication experience for their customers within web and mobile applications. By leveraging Twilio's APIs, developers can swiftly integrate functionalities such as voice messages, video calls, text messages, and more into an application.
Twilio provides you with a Sandbox account so you can try the service for free.
Register a Twilio account
.
If you want to take a closer look at the process of setting up your Twilio environment to start creating your chatbot, click here.
More info about Twilio Deploy
Uses Cases
If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider. Cases such as sending buttons, lists, or native methods directly with Meta
More info about Twilio uses cases
Send Buttons
One of the most requested functions by users is the fact of
sending buttons
to generate more interactivity and more dynamic chatbots.
app.ts
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'template'
,
'plantilla'
])
.addAction
(
async
(ctx)
=>
{
await
provider
.send
(
ctx
.from
,
'Agregar dos botones que permiten al cliente dar una respuesta mas rapida'
,
{
contentSid
:
'HXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
}
)
})
Copy
Copied!
Remember that the use of buttons, lists and other featured Whatsapp functionality needs to be a template authorized by the provider.
contentSid
is the id of the approved template you can use.
Content Quick
Remember for correct functionality you must have the message comply with the message template constructed.
Buttons Examples
Content Template Builder
The Content Template Builder is a Twilio product designed to create template messages and content-rich messages. It has an easy-to-use graphical interface built on a publicly accessible API. With the Content Template Builder, both engineers and non-technical users can create, approve and manage templates from the Twilio Console.
With this system, it is possible to create templates faster, with fewer errors, while empowering the entire team to contribute. Both developers and non-technical users can build and submit templates for approval from the Twilio Console without writing a single line of code.
Content Templates
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_twilio_deploy.txt ---
Twilio Setup - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Setup
Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communication APIs empower businesses to provide the appropriate communication experience for their customers within web and mobile applications. By leveraging Twilio's APIs, developers can swiftly integrate functionalities such as voice messages, video calls, text messages, and more into an application.
Twilio provides you with a Sandbox account so you can try the service for free.
Register a Twilio account
.
Requirements
We must accept the terms and conditions and then activate the sandbox account.
Sandbox
We note that we now have a WhatsApp number and a phrase. The number provided is a
trial number
that Twilio offers you, after you activate a payment plan you can purchase a number for your use. Save that number as a WhatsApp contact on your mobile and then send it the message assigned to you. In the example on the screen,
join score-state appears
Join to sandbox
Twilio then responds with a message confirming the connection verification.
This step is only necessary when you are in Sandbox mode
.
Test your Whatsapp
Now go to the WhatsApp Settings section located in the Twilio console.
In this section, you can configure the
Webhooks
that connect to the chatbot.
Don't know what your link is?
Continue reading this guide later you will understand.
You will also need the
Account SID and Auth Token
, these data are obtained from
console.twilio.com
.
What do I do with this data?
Save them or have them located because we will need them on the following screens.
In the
main file
of the bot where you are implementing the Twilio adapter function you are going to place the following data:
ACC_SID:
You will find it in the Twilio console, you can see the previous screen.
ACC_TOKEN:
You will find it in the Twilio console, you can see the previous screen.
ACC_VENDOR:
It is the WhatsApp number (if you already have the Twilio payment plan, use the number you purchased), if you are still in sandbox mode, use the number provided in step number 2.
In the example below you can see a suggestion of what it can be like using environment variables
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ TwilioProvider }
from
'@builderbot/provider-twilio'
const
welcomeFlow
=
addKeyword
<
TwilioProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(TwilioProvider
,
{
accountSid
:
process
.
env
.
ACC_SID
,
//AC4695aa720b4d700a***************
authToken
:
process
.
env
.
ACC_TOKEN
,
//3f6fae09f7a1c3534***************
vendorNumber
:
process
.
env
.
ACC_VENDOR
,
//+14155238886
})
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
After running the bot you will find a message in the console similar to the following. Where you can find the URL for your
webhook
$
npm
start
>
bot-whatsapp-base-twilio-memory@1.0.0 start
>
node app.js
[Twilio]: Agregar esta url
"WHEN A MESSAGE COMES IN"
[Twilio]: POST http://localhost:3000/twilio-hook
[Twilio]: Más información en la documentacion
Copy
Copied!
What do I do now?
You will see that the bot starts an HTTP service (endpoint) that must be on an online server so you can connect it to Twilio.
Option 1
You can test locally through a tunnel proxy server. Download
ngork
is a free tool that will help us with this.
This generates an inline URL that we can use in the
WebHook
part of Twilio
Option 2
If you already have your bot deployed on a server, you have to obtain the public IP or subdomain that they provided you. Example, if you are using
Railway
you can go to the settings section and generate a subdomain. We would already have the WebHook
https://base-twilio-memory-production.up.railway.app/twilio-hook
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de providers_twilio_uses-cases.txt ---
Twilio Uses Cases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Twilio Uses Cases
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ TwilioProvider
as
Provider }
from
'@builderbot/provider-twilio'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'test'
])
.addAnswer
(
'send files...'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://builderbot.vercel.app/_next/static/media/logo-v2.5d15651a.png'
}
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send audio from URL`
,
{ media
:
'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
.addAnswer
(
`First Way to Send Buttons`
,
{
buttons
:
[
{ body
:
'Order'
}
,
{ body
:
'Register'
}
,
{ body
:
'Catalog'
}
]
})
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider
,
{
accountSid
:
process
.
env
.
ACCOUNT_SID
,
authToken
:
process
.
env
.
AUTH_TOKEN
,
vendorNumber
:
process
.
env
.
VENDOR_NUMBER
,
})
const
adapterDB
=
new
Database
()
const
{
handleCtx
,
httpServer
}
=
await
createBot
<
Provider
>({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
adapterProvider
.
server
.post
(
'/v1/samples'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
try
{
const
{
number
,
message
,
urlMedia
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media
:
urlMedia
??
null
})
await
bot
.
provider
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'ok'
)
}
catch
(error) {
console
.log
(error)
return
res
.end
(
'error'
)
}
})
)
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de quickstart.txt ---
Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Create
Requirements
Base Example
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Create
Creating a bot is as simple as running the following command and following the instructions
Prerequisites to consider before using this tool,
Node
v20 or higher and
Git
pnpm
npm
pnpm
create
builderbot@latest
Copy
Copied!
or you can use the following command to create a bot with the default configuration
pnpm
npm
pnpm
create
builderbot@latest
--provider=baileys
--database=memory
--language=ts
Copy
Copied!
Use the space key to select and the enter key to confirm. The CLI performs a preliminary check of the Node and operating system version, informing you if it meets the requirements or providing you with relevant information. In addition to generating a base project for you to simply start up
If you have problems with your terminal try running the command with
CMD, PowerShell, GitBash
or another console you have installed.
Requirements
Make sure you have installed Node version
20 or higher
, below you can see an example to check the version of node you are using.
Node Version
node
-v
v20.10.0
Copy
Copied!
Download node from its official website
It is recommended to have GIT installed for proper operation. If you are using Linux or MacOc you probably already have GIT installed by default.
Git Version
git
-v
git
version
XXXX
Copy
Copied!
Download GIT from its official website
Base Example
In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are:
info, hello, hi
. You can see how to create the bot and implement the
flows
.
main.ts
main.js
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
/** send static messages */
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hello'
,
'hi'
])
.addAnswer
(
'Ey! welcome'
)
/** send dynamic message from db or other sources */
const
infoFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>(
'info'
)
.addAction
(
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
(
`Welcome
${
ctx
.name
}
`
)
})
/** send media files */
const
mediaFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>(
'image'
)
.addAnswer
(
`Send Image A`
,
{ media
:
'https://i.imgur.com/AsvWfUX.png'
})
.addAction
(
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
(
`Welcome
${
ctx
.name
}
`
)
await
flowDynamic
(
[
{
body
:
'Send Image B'
,
media
:
'https://i.imgur.com/w0RtKnN.png'
}
]
)
})
/** initialization bot */
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow
,
infoFlow
,
mediaFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de resources.txt ---
BuilderBot Brand Guidelines and Assets - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Logo Pack
Brand Assets
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
BuilderBot Brand Guidelines and Assets
Avoid representing the BuilderBot brand in a way that:
Implies partnership, sponsorship or endorsement.
Makes the BuilderBot brand the most distinctive or prominent feature.
Puts the BuilderBot brand in a negative context as part of a script or storyline. You must comply with our Terms of Use and Community Guidelines.
Keep the word BuilderBot consistent
Avoid representing the BuilderBot brand in a way that:
Keep the letters "B" in BuilderBot capitalized and in the same font size and style as the content surrounding it.
If you offer an app, website or a product or service that uses the BuilderBot APIs or is otherwise compatible with or related to BuilderBot, you may only use BuilderBot to say that your app is "for BuilderBot" or that the name of your campaign is "on BuilderBot" in a descriptive manner.
Don't modify, abbreviate or translate the word BuilderBot to a different language or by using non-English characters, or use any of our logos to replace it.
Don't combine "Builder" or "Bot" with your own brand.
Don't combine any part of the BuilderBot brand with a company name, other trademarks, or generic terms.
Distance BuilderBot from other platforms
BuilderBot may be mentioned in a television commercial with its parent company or other affiliated companies.
Don't mention other similar platforms in the same spot as BuilderBot, unless it's a general "Find us on..." call to action.
If you create a hashtag that uses the word Builder or Bot, it shouldn't be used on other platforms and you shouldn't try to acquire or enforce rights over that hashtag.
Logo Pack
I have read and accept the applicable guidelines and other terms for use.
Download BuilderBot Horizontal Logo (PNG)
Download BuilderBot Logo (SVG)
Download BuilderBot Logo (PNG)
Download BuilderBot Black Logo (PNG)
Download BuilderBot White Logo (PNG)
Download BuilderBot White Line Logo (PNG)
Download BuilderBot Full Logo (PNG)
Download BuilderBot Full Line Logo (PNG)
Download BuilderBot Transparent Line Logo (PNG)
Download BuilderBot Mini Logo (PNG)
Download BuilderBot Thumbnail Vector (PNG)
Brand Assets
Here's a color guide for inspiration that you can use
Teal
#20E3B2
Copy
Dark Blue
#0F172A
Copy
Light Gray
#F1F5F9
Copy
Dark Gray
#64748B
Copy
White
#FFFFFF
Copy
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_cron-reminder.txt ---
Reminder (cron) - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Reminder (cron)
Issue
I need to send individual reminders every so often to users, reminding them to perform a task or complete a purchase.
Possible Solution
For this we will need to install some dependencies that will facilitate the work of the scheduled tasks, we will use
node-cron
below you will find the instructions on how to install
install
pnpm
i
node-cron
pnpm
i
@types/node-cron
-D
Copy
Copied!
We have seen how we declare a logic that runs every 12 hours
0 */12 * * *
cron guru
where it makes a request to an api that can also be a query to the database to retrieve which are those user numbers to which we want to send a message.
It is recommended that you have a varied list of welcome messages to avoid possible bans.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ schedule }
from
'node-cron'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
<
Provider
,
Database
>([
'hi'
,
'hello'
,
'hola'
])
.addAnswer
(
`🙌 Hello welcome to this *Chatbot*`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
/**
* It is recommended to have an array of messages with which you will
* greet or make that first contact with the user to
* avoid robotic behavior and possible bans
*/
schedule
(
'0 */12 * * *'
,
async
()
=>
{
console
.log
(
'running a task twelve hours'
);
const
usersApi
=
await
fetch
(
'http://your.api/users'
)
const
users
=
await
usersApi
.json
()
const
listMessages
=
[
`Your message!`
,
'Ey how are you?'
,
'How do you doing?'
]
for
(
const
user
of
users) {
const
randomMessage
=
listMessages[
Math
.floor
(
Math
.random
()
*
listMessages
.
length
)]
await
adapterProvider
.sendMessage
(
user
.number
,
randomMessage
,
{})
await
utils
.delay
(
5000
)
}
});
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_docker-pm2.txt ---
Scheduled Reboots - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Scheduled Reboots
Issue
Occasionally, the bot's programming seems to be unresponsive or the server does not have enough resources.
Possible Solution
When using the free providers we will need to restart the bot to avoid accumulating temporary data that may affect its performance. In that case an easy solution to implement is to schedule restarts, these restarts will not need to scan the QR again.
Docker and Pm2 One way to do it if you are using docker could be to implement in your docker image Pm2 and with pm2-runtime start your container with a cron pattern.
In the following Dockerfile we can see how we start the project with a pattern
0 */12 * * *
that means that it will restart every 12 hours
Dockerfile
# Use the official Node.js image as the base image for building the application.
FROM
node:21-alpine3.18
as
builder
# Enable Corepack and prepare for PNPM installation
RUN
corepack enable && corepack prepare pnpm@latest --activate
ENV
PNPM_HOME=/usr/local/bin
# Set the working directory inside the container
WORKDIR
/app
# Copy package.json and pnpm-lock.yaml files to the working directory
COPY
package*.json pnpm-lock.yaml ./
# Install git for potential dependencies
RUN
apk add --no-cache git
# Install PM2 globally using PNPM
RUN
pnpm install pm2 -g
# Copy the application source code into the container
COPY
. .
# Install dependencies using PNPM
RUN
pnpm install
# Create a new stage for deployment
FROM
builder
as
deploy
# Copy only necessary files and directories for deployment
COPY
--from=builder /app/src ./src
COPY
--from=builder /app/package.json /app/pnpm-lock.yaml ./
# Install production dependencies using frozen lock file
RUN
pnpm install --frozen-lockfile --production
# Define the command to start the application using PM2 runtime
CMD
[
"pm2-runtime"
,
"start"
,
"./src/app.js"
,
"--cron"
,
"0 */12 * * *"
]
Copy
Copied!
Remember that this is an alternative solution, and it is possible that its implementation could be improved.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_event-in-out-messages.txt ---
Incoming and outgoing messages - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Incoming and outgoing messages
Issue
Sometimes we will need to listen to the events of incoming or outgoing messages, this is often necessary when we are connecting our chatbot with third party UI applications.
Possible Solution
In the example below we show a code which you can execute and observe the messages in the console. The objective is to capture the incoming and outgoing message from the bot.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3008
const
welcomeFlow
=
addKeyword
(
'hello!'
)
.addAnswer
(
'Welcome!'
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
bot
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
bot
.httpServer
(
+
PORT
)
adapterProvider
.on
(
'message'
,
({ body
,
from })
=>
{
console
.log
(
`Message Payload:`
,
{ body
,
from })
})
bot
.on
(
'send_message'
,
({ answer
,
from })
=>
{
console
.log
(
`Send Message Payload:`
,
{ answer
,
from })
})
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_fast-entires.txt ---
Fast Entries - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Issue
Improved Solution
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Fast Entries
Issue
Sometimes it happens that people are impatient and write independent messages in a very short time gap preventing the bot to answer, which makes that each message is answered but not in the desired order.
Improved Solution
For this type of environment, we've implemented an enhanced functionality that introduces a margin of 3000ms for the user to write messages. Each time a user writes a message within this 3000ms window, it accumulates all the messages. After the margin time expires, the bot interprets everything as a single conversation.
This implementation ensures that before passing to the processing stage, all independent messages (e.g., 3) become one (1) and are processed as a single message.
In this example, we use
3000ms
(equal to 3 seconds) as the default gap, but you can modify this to your liking by adjusting the
gapSeconds
in the
QueueConfig
.
Video Fast Entries
fast-entires.ts
app.ts
/**
*
@file
multiUserMessageQueue.ts
*
@description
An improved functional implementation of a multi-user message queueing system with debounce functionality,
* ensuring separate conversation handling for each user.
*/
import
{ BotContext }
from
"@builderbot/bot/dist/types"
;
interface
Message
{
text
:
string
;
timestamp
:
number
;
}
interface
QueueConfig
{
gapMilliseconds
:
number
;
}
interface
UserQueue
{
messages
:
Message
[];
timer
:
NodeJS
.
Timeout
|
null
;
callback
:
((body
:
string
,
from
:
string
)
=>
void
)
|
null
;
}
interface
QueueState
{
queues
:
Map
<
string
,
UserQueue
>;
}
function
createInitialState
()
:
QueueState
{
return
{
queues
:
new
Map
()
};
}
function
resetTimer
(userQueue
:
UserQueue
)
:
UserQueue
{
if
(
userQueue
.timer) {
clearTimeout
(
userQueue
.timer);
}
return
{
...
userQueue
,
timer
:
null
};
}
function
processQueue
(messages
:
Message
[])
:
string
{
const
result
=
messages
.map
(message
=>
message
.text)
.join
(
" "
);
console
.log
(
'Accumulated messages:'
,
result);
return
result;
}
function
createMessageQueue
(config
:
QueueConfig
) {
let
state
:
QueueState
=
createInitialState
();
return
function
enqueueMessage
(ctx
:
BotContext
,
callback
:
(body
:
string
,
from
:
string
)
=>
void
)
:
void
{
const
from
=
ctx
.from;
const
messageBody
=
ctx
.body;
if
(
!
from
||
!
messageBody) {
console
.error
(
'Invalid message context:'
,
ctx);
return
;
}
console
.log
(
'Enqueueing:'
,
messageBody
,
'from:'
,
from);
let
userQueue
=
state
.
queues
.get
(from);
if
(
!
userQueue) {
userQueue
=
{ messages
:
[]
,
timer
:
null
,
callback
:
null
};
state
.
queues
.set
(from
,
userQueue);
}
userQueue
=
resetTimer
(userQueue);
userQueue
.
messages
.push
({ text
:
messageBody
,
timestamp
:
Date
.now
() });
userQueue
.callback
=
callback;
console
.log
(
'Messages for'
,
from
,
':'
,
userQueue
.messages);
if
(
!
userQueue
.timer) {
userQueue
.timer
=
setTimeout
(()
=>
{
const
currentQueue
=
state
.
queues
.get
(from);
if
(currentQueue) {
const
result
=
processQueue
(
currentQueue
.messages);
if
(
currentQueue
.callback) {
currentQueue
.callback
(result
,
from);
}
state
.
queues
.set
(from
,
{
...
currentQueue
,
messages
:
[]
,
timer
:
null
});
}
}
,
config
.gapMilliseconds);
}
state
.
queues
.set
(from
,
userQueue);
};
}
export
{ createMessageQueue
,
QueueConfig };
Copy
Copied!
Key Improvements in the New Implementation:
Functional Approach
: The new implementation uses a functional programming style, which can lead to more predictable and testable code.
Immutable State
: The state of the queue is managed immutably, which helps prevent unexpected side effects.
Flexible Configuration
: The
QueueConfig
interface allows for easy adjustment of the gap time.
Enhanced Error Handling
: The implementation includes try-catch blocks for better error management.
Callback-based Processing
: Instead of returning a promise, the new implementation uses a callback function, allowing for more flexible message processing.
Detailed Logging
: Console logs have been added at key points to aid in debugging and understanding the message flow.
Remember that while this implementation offers significant improvements, it's always possible to further optimize based on specific use cases and requirements.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_forward-conversation-to-human.txt ---
Forward conversation to human - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Forward conversation to human
Issue
I need to be able to stop the bot to continue the conversation with one person but still allow other people to see it.
Possible Solution
In this example let's imagine that the bot number is
ADMIN_NUMBER
the idea is that if a user writes me the bot will answer this is correct, but
I want to pause the bot for that user, what I do is write to my own number from the whatsapp with a phrase
Mute +34000000
assuming that the number
of the user I want to pause is
+34000000
and the logic I perform is to clean characters to only get
34000000
and check if it exists in a
blackList
if it is not found I add it in this way the bot stops responding to that
user and I can continue talking to the person and when I want to reactivate the bot for this person I write again
Mute +34000000
and if it is found it removes it from the blacklist is basically a switch.
app.ts
util.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
utils }
from
'@builderbot/bot'
import
{ MemoryDB
as
Database }
from
'@builderbot/bot'
import
{ BaileysProvider
as
Provider }
from
'@builderbot/provider-baileys'
import
{ numberClean }
from
'./utils'
const
PORT
=
process
.
env
.
PORT
??
3008
const
ADMIN_NUMBER
=
process
.
env
.
ADMIN_NUMBER
const
blackListFlow
=
addKeyword
<
Provider
,
Database
>(
'mute'
)
.addAction
(
async
(ctx
,
{ blacklist
,
flowDynamic })
=>
{
if
(
ctx
.from
===
ADMIN_NUMBER
) {
const
toMute
=
numberClean
(
ctx
.body)
//Mute +34000000 message incoming
const
check
=
blacklist
.checkIf
(toMute)
if
(
!
check) {
blacklist
.add
(toMute)
await
flowDynamic
(
`❌
${
toMute
}
muted`
)
return
}
blacklist
.remove
(toMute)
await
flowDynamic
(
`🆗
${
toMute
}
unmuted`
)
return
}
})
const
fullSamplesFlow
=
addKeyword
<
Provider
,
Database
>([
'samples'
,
utils
.setEvent
(
'SAMPLES'
)])
.addAnswer
(
`💪 I'll send you a lot files...`
)
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([fullSamplesFlow
,
blackListFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_gotoflow-use.txt ---
How to Use GotoFlow? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
How to Use GotoFlow?
Issue
I needed to be able to detect users that were already registered in my system so I need to make a get http query to my external system to check if that number was registered or not and depending on that divert it to a convenient flow.
Possible Solution
A possible solution is to make use of the gotoFlow to be able to divert the logic depending on the response of the http request to be able to verify if the user is registered in the database or is a new user.
registered in the database or is a new user.
app.ts
unregisteredUsersFlow.ts
registeredUsersFlow.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB
,
EVENTS }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
"@builderbot/provider-baileys"
;
import
registeredUsersFlow
from
"./flows/registeredUsersFlow"
;
import
unregisteredUsersFlow
from
"./flows/unregisteredUsersFlow"
;
const
welcomeFlow
=
addKeyword
(
EVENTS
.
WELCOME
)
.addAction
(
async
(_
,
{ gotoFlow
,
state })
=>
{
const
checkDB
=
await
fetch
(
"http://my.app.example/checkDB"
,
{
method
:
"POST"
,
body
:
JSON
.stringify
({ phoneNumber
:
state
.from })
,
headers
:
{
"Content-Type"
:
"application/json"
,
}
,
});
const
status
=
await
checkDB
.json
();
if
(status
===
undefined
) {
await
state
.update
({ Registration
:
false
});
return
gotoFlow
(unregisteredUsersFlow);
}
if
(status
===
true
) {
return
gotoFlow
(registeredUsersFlow);
}
}
);
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider);
const
database
=
new
MemoryDB
();
const
flow
=
createFlow
([welcomeFlow
,
registeredUsersFlow
,
unregisteredUsersFlow]);
await
createBot
({ flow
,
provider
,
database });
};
main
();
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_idle-optional.txt ---
Idle - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Idle
Issue
I need to wait for the customer's response but only for a limited time.
Possible Solution
The inactivity of flows in our business logic can become a nuisance, that is why we share the following resources as an alternative solution to this situation.
Create a file named
idle-custom.ts
and paste the following code:
idle-custom.ts
import
{ EVENTS
,
addKeyword }
from
'@builderbot/bot'
import
{ BotContext
,
TFlow }
from
'@builderbot/bot/dist/types'
;
// Object to store timers for each user
const
timers
=
{};
// Flow for handling inactivity
const
idleFlow
=
addKeyword
(
EVENTS
.
ACTION
)
.addAction
(
async
(_
,
{ endFlow })
=>
{
return
endFlow
(
"Response time has expired"
);
}
);
// Function to start the inactivity timer for a user
const
start
=
(ctx
:
BotContext
,
gotoFlow
:
(a
:
TFlow
)
=>
Promise
<
void
>
,
ms
:
number
)
=>
{
timers[
ctx
.from]
=
setTimeout
(()
=>
{
console
.log
(
`User timeout:
${
ctx
.from
}
`
);
return
gotoFlow
(idleFlow);
}
,
ms);
}
// Function to reset the inactivity timer for a user
const
reset
=
(ctx
:
BotContext
,
gotoFlow
:
(a
:
TFlow
)
=>
Promise
<
void
>
,
ms
:
number
)
=>
{
stop
(ctx);
if
(timers[
ctx
.from]) {
console
.log
(
`reset countdown for the user:
${
ctx
.from
}
`
);
clearTimeout
(timers[
ctx
.from]);
}
start
(ctx
,
gotoFlow
,
ms);
}
// Function to stop the inactivity timer for a user
const
stop
=
(ctx
:
BotContext
)
=>
{
if
(timers[
ctx
.from]) {
clearTimeout
(timers[
ctx
.from]);
}
}
export
{
start
,
reset
,
stop
,
idleFlow
,
}
Copy
Copied!
Remember
to add this flow to your project's main flow array
app.ts
import
{ idleFlow }
from
'./idle-custom'
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([welcomeFlow
,
registerFlow
,
idleFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
Copy
Copied!
Start Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
Name
gotoFlow
Type
TFlow
Description
Function providing the execution flow
Name
ms
Type
number
Description
Number of milliseconds to be set
const
questionFlow
=
addKeyword
(
"hello"
)
.addAction
(
async
(ctx
,
{ gotoFlow })
=>
{
start
(ctx
,
gotoFlow
,
10000
)
})
Copy
Copied!
Reset Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
Name
gotoFlow
Type
TFlow
Description
Function providing the execution flow
Name
ms
Type
number
Description
Number of milliseconds to be set
// ...
.addAnswer
(
"Give me your last name"
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ lastName
:
ctx
.body });
}
)
// ...
Copy
Copied!
Stop Inactivity
Name
ctx
Type
BotContext
Description
Current execution context
// ...
.addAnswer
(
"Thank you!"
,
null
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
stop
(ctx);
}
)
// ...
Copy
Copied!
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword }
from
'@bot-whatsapp/bot'
import
{ MemoryDB
as
Database }
from
'@bot-whatsapp/bot'
import
{ BaileysProvider
as
Provider }
from
'@bot-whatsapp/provider-baileys'
import
{ idleFlow
,
reset
,
start
,
stop
,
}
from
'./idle-custom'
const
PORT
=
process
.
env
.
PORT
??
3008
const
questionFlow
=
addKeyword
(
"hello"
)
.addAction
(
async
(ctx
,
{ gotoFlow })
=>
start
(ctx
,
gotoFlow
,
10000
))
.addAnswer
(
[
"This is a test of the Home idle, if you do not respond within 10 seconds I will end the flow."
,
"Give me your name"
,
]
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ name
:
ctx
.body });
}
)
.addAnswer
(
"Give me your last name"
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
state })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
await
state
.update
({ lastName
:
ctx
.body });
}
)
.addAnswer
(
"Finally, answer this simple question by typing the number between [1, 2]."
,
{ capture
:
true
}
,
async
(ctx
,
{ gotoFlow
,
endFlow
,
fallBack })
=>
{
reset
(ctx
,
gotoFlow
,
10000
);
switch
(
ctx
.body) {
case
"1"
:
stop
(ctx);
return
endFlow
(
`Nice 1`
);
case
"2"
:
stop
(ctx);
return
endFlow
(
`Ok 2`
);
default
:
return
fallBack
(
`I only accept *numbers* that are between [1, 2].`
);
}
}
);
const
main
=
async
()
=>
{
const
adapterFlow
=
createFlow
([questionFlow
,
idleFlow])
const
adapterProvider
=
createProvider
(Provider)
const
adapterDB
=
new
Database
()
const
{
httpServer
}
=
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
httpServer
(
+
PORT
)
}
main
()
Copy
Copied!
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_modularize.txt ---
Modularize Flows - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Modularize Flows
Issue
My application grew so large that I was having trouble maintaining it and the code was becoming spaghetti code.
Possible Solution
As our projects grow we will need to implement a better way to maintain the project, in this case it is highly recommended to implement a module view.
In the following example we will show how we have migrated the modules to a directory, as well as the provider and the database.
app.ts
provider/index.ts
database/index.ts
flow/index.ts
flow/welcome.flow.ts
services/ai.ts
import
{ createBot }
from
'@builderbot/bot'
;
import
{ flow }
from
"./flow"
;
import
{ database }
from
"./database"
;
import
{ provider }
from
"./provider"
;
import
{ ai }
from
"./services/ai"
;
const
main
=
async
()
=>
{
await
createBot
({
flow
,
provider
,
database
,
}
,
extensions: {
ai
// Dependency AI
})
provider
.initHttpServer
(
3000
)
}
main
()
Copy
Copied!
An example of the scaffolding you can use in your project. Or a more user friendly folder structure.
structure
src
├── app.ts
├── database
│   └── index.ts
├── flow
│   ├── index.ts
│   └── welcome.flow.ts
│   └── bye.flow.ts
│   └── media.flow.ts
├── provider
│   └── index.ts
└── services
    └── ai.ts
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_multiple-messages.txt ---
Multiple messages - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Multiple messages
Issue
Sometimes, you need the bot to generate responses based on an event such as receiving images from users, but you don't want the bot to throw multiple and redundant responses if the user quickly sends several images.
Possible Solution
To ensure that the bot responds only once despite receiving too many calls in a short period of time, a debounce decorator could be implemented around the gotoFlow and endFlow methods.
In the example below I will show you how I implemented this solution in my bot to analyze several images and depending on whether they are images of furniture or not, terminate the flow with an error message or send it to another registration flow
media-flow.ts
debounce.ts
import
path
from
"node:path"
;
import
fs
from
"node:fs/promises"
;
import
process
from
"node:process"
;
import
{ addKeyword
,
EVENTS }
from
"@builderbot/bot"
;
import
{ BaileysProvider }
from
"@builderbot/provider-baileys"
;
import
{ UrlToBase64 }
from
"@builderbot-plugins/url-to-base64"
;
import
{ PROMPT_IMAGE }
from
"./prompt"
;
import
{ debounce }
from
"~/utils/debounce"
;
import
AIClass
from
"~/services/OpenAIService"
;
import
{ registerFlow }
from
"../order/register.flow"
;
const
localPaths
=
[];
let
debouncedEndFlow
:
(
...
args
:
any
[])
=>
void
;
let
debouncedGoToFlow
:
(
...
args
:
any
[])
=>
void
;
const
filePath
=
path
.join
(
process
.cwd
()
,
'src'
,
'database'
,
'images'
);
export
const
mediaFlow
=
addKeyword
<
BaileysProvider
>(
EVENTS
.
MEDIA
)
.addAction
(
async
(ctx
,
{ provider
,
queue })
=>
{
await
queue
.enqueue
(
'processImage'
,
async
()
=>
{
const
localPath
=
await
provider
.saveFile
(ctx
,
{ path
:
filePath });
localPaths
.push
(localPath);
}
,
'imageProcessingTask'
);
await
queue
.processQueue
(
'processImage'
);
await
queue
.clearQueue
(
'processImage'
);
queue
.clearAndDone
(
'processImage'
,
{fingerIdRef
:
'imageProcessingTask'
});
})
.addAction
(
async
(_
,
{ extensions
,
gotoFlow
,
endFlow })
=>
{
const
ai
=
extensions
.ai
as
AIClass
;
if
(
!
debouncedEndFlow
&&
!
debouncedGoToFlow){
debouncedEndFlow
=
debounce
(endFlow
,
1500
);
debouncedGoToFlow
=
debounce
(gotoFlow
,
1500
);
}
for
(
const
path
of
localPaths) {
const
{
data
,
mimetype
}
=
UrlToBase64
.fromFilePath
(path);
const
aiResponse
=
await
ai
.readImage
(data
,
PROMPT_IMAGE
,
mimetype);
if
(
aiResponse
.includes
(
'NOT_FURNITURE'
)) {
for
(
const
filePath
of
localPaths) {
await
fs
.unlink
(filePath);
}
localPaths
.
length
=
0
;
return
debouncedEndFlow
(
'Ups! Asegurate de enviar una foto correcta de un mueble'
);
}
}
localPaths
.
length
=
0
;
return
debouncedGoToFlow
(registerFlow)
})
Copy
Copied!
Remember that this is an alternative solution, and it is possible that its implementation could be improved.
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de showcases_queue-limit.txt ---
Queue Limit - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Queue Limit
Issue
The problem was that when more than 60 people started a conversation in less than 20 seconds the bot did not respond to all the people.
Possible Solution
The framework by default implements a queue manager based on per-user work promises.
If you already understand the concept and you are in an environment where you receive a considerable number of recurring messages in a short period of time and you notice that it answers a large number of users but not all of them. You can try extending the process queue configuration.
Imagine the case
in which you receive more than 60 messages from more than 60 people in a very short period of time of less than 20 seconds for example
It is very likely that it will not respond to all users, since the default configuration of the bot is set to handle a smaller amount of processes, but it is very easy to modify.
app.ts
const
main
=
async
() => {
await
createBot
({
database:
new
MemoryDB
()
,
provider:
createProvider
(
BaileysProvider
)
,
flow:
createFlow
([...])
}, {
queue:
{
timeout:
20000
,
//👌
concurrencyLimit:
50
//👌
}
})
}
Copy
Copied!
Name
timeout
Type
number
Description
Number of milliseconds used as maximum duration for the execution of an asynchronous function.
default 20000
Name
concurrencyLimit
Type
number
Description
Number of parallel processes you can be running at the same time.
default 15
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de tutorials_api-use.txt ---
How to implement a REST API? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Send Single Message
Send with Media
Block Users
Trigger Flows
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
How to implement a REST API?
In many occasions we need to send a message via HTTP request is very useful to send reminders or order confirmations. In this case each provider implements a
handleCtx
function which allows you to inject the bot instantiation and access its functions from a controller.
Send Single Message
Request
POST
/v1/messages
curl
https://api.example.chat/v1/messages
\
-d
number=
"34000000"
\
-d
message=
"Hello!"
Copy
Copied!
In the exercise below you can get an example of how it works. It is interesting to understand that internally the library already implements a very light version of HTTP similar to express but called
polka
.
app.ts
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{})
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Send with Media
Request
Media Link
Media Local
POST
/v1/messages
curl
https://api.example.chat/v1/messages
\
-d
number=
"34000000"
\
-d
message=
"Ey! send media"
Copy
Copied!
In the following example you will understand how to send files, images or videos from an api when the file is in a public URL or also if you want to upload it through a request.
app-media.ts
app-media.storage.ts
import
'dotenv/config'
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/messages'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
message
,
media
}
=
req
.body
await
bot
.sendMessage
(number
,
message
,
{ media })
// https://i.imgur.com/0HpzsEm.png
return
res
.end
(
'send'
)
}))
}
main
()
Copy
Copied!
Block Users
Request
POST
/v1/blacklist
curl
https://api.example.chat/v1/blacklist
\
-d
number=
"34000000"
\
-d
intent=
"'add' or 'remove'"
Copy
Copied!
In the following example you will understand how to add numbers to a blacklist to prevent the bot from answering those numbers, very useful when we want to talk to a person without the bot answering.
blacklist-api.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
import
flow
from
'./flows'
;
const
PORT
=
process
.
env
.
PORT
??
3001
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/blacklist'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
intent
}
=
req
.body
if
(intent
===
'remove'
)
bot
.
blacklist
.remove
(
`340000000`
)
if
(intent
===
'add'
)
bot
.
blacklist
.add
(
`340000000`
)
res
.writeHead
(
200
,
{
'Content-Type'
:
'application/json'
})
return
res
.end
(
JSON
.stringify
({ status
:
'ok'
,
number
,
intent }))
}))
}
main
()
Copy
Copied!
Trigger Flows
Request
POST
/v1/register
curl
https://api.example.chat/v1/register
\
-d
number=
"34000000"
\
-d
name
=
"Joe"
Copy
Copied!
In the following example you will understand how to start a flow to a given number from an API request, it is a new experimental function that may undergo changes in the future.
trigger-flow-api.ts
import
{ createBot
,
MemoryDB
,
createProvider }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
PORT
=
process
.
env
.
PORT
??
3001
const
registerFlow
=
addKeyword
(
utils
.setEvent
(
'EVENT_REGISTER'
))
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAnswer
(
'What is your age?'
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ age
:
ctx
.body })
})
.addAction
(
async
(_
,
{ flowDynamic
,
state })
=>
{
await
flowDynamic
(
`
${
state
.get
(
'name'
)
}
, thanks for your information!: Your age:
${
state
.get
(
'age'
)
}
`
)
})
const
main
=
async
()
=>
{
const
provider
=
createProvider
(BaileysProvider)
const
{
handleCtx
,
httpServer
}
=
await
createBot
({
database
:
new
MemoryDB
()
,
provider
,
flow
:
createFlow
([registerFlow])
,
})
httpServer
(
+
PORT
)
provider
.
server
.post
(
'/v1/register'
,
handleCtx
(
async
(bot
,
req
,
res)
=>
{
const
{
number
,
name
}
=
req
.body
await
bot
.dispatch
(
'EVENT_REGISTER'
,
{ from
:
number
,
name })
return
res
.end
(
'trigger'
)
}))
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de tutorials_chatbot-with-gemini.txt ---
Chatbot with Context - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Install Gemini
Context Example
Vision Example
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Chatbot with Context
The gemini model is a generous and valuable resource to use if it comes to creating a product with AI that has both vision and text generation and without spending a penny is what we want.
To start remember to install the gemini plugin and have your
Google Api key
Install Gemini
We started the installation of a package that will help you to implement the Gemin power in builderbot.
pnpm
install
@builderbot-plugins/gemini-layer
Copy
Copied!
More info about it
Context Example
Sometimes we don't want to place so many keywords or answers in validations of our flows, we want some freedom when it comes to responding, that's why we have the gemini plugin to respond based on a context
the context indicates between key value, the different scenarios in which the user may be when interacting with the assistant
context
: It is the object that will contain all the necessary properties you need.
layers/context.layer.ts
flows/context.flow.ts
app.ts
import
{ geminiLayer }
from
"@builderbot-plugins/gemini-layer"
export
default
async
(
...
bot
:
any
)
=>
await
geminiLayer
({
context
:
{
name
:
'your name'
,
email
:
'your email'
,
summary
:
'your summary'
// and more properties
}
}
,
bot)
Copy
Copied!
Vision Example
Field
Description
vision
true
visionPrompt
What you want the model to see
image_path
The route where the image will be downloaded to be analyzed later
cb
A callback that receives the same interface as addAction and which returns an answer in the state
layers/image.layer.ts
flows/image.flow.ts
app.ts
import
{ geminiLayer }
from
"@builderbot-plugins/gemini-layer"
const
visionPrompt
=
'Give me a brief summary of what you see in the picture'
export
default
async
(
...
bot
:
any
)
=>
await
geminiLayer
({
vision
:
true
,
visionPrompt
,
image_path
:
'./'
,
cb
:
async
(_
,
{ state
,
gotoFlow })
=>
{
const
{
answer
}
=
state
.getMyState
()
console
.log
(
'answer about image'
,
answer)
if
(answer
===
'anything else you want to validate'
) {
return
gotoFlow
(
'any flow you want to go'
)
}
}
}
,
bot)
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de tutorials_langchain.txt ---
Langchain - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Install
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Langchain
When we want something more personality and intelligence in our assistants, the first thing we think about is Openai, what if I tell you that there is a simple way to get the most out of your LLM?
Install
let's look at a simple but very valuable trick. to be able to know the user's intention, we have tried it before with DialogFlow but what a headache, let's go for something easier
pnpm
i
@langchain/openai
@langchain/core
zod
Copy
Copied!
ai/catch-intention.ts
app.ts
import
{ z }
from
"zod"
;
import
{ ChatOpenAI
,
ChatPromptTemplate }
from
"@langchain/openai"
;
export
const
openAI
=
new
ChatOpenAI
({
modelName
:
'gpt-4'
,
openAIApiKey
:
'YOUR_API_KEY_HERE'
,
});
const
SYSTEM_STRUCT
=
`just only history based:
{history}
Answer the users question as best as possible.`
;
export
const
PROMPT_STRUCT
=
ChatPromptTemplate
.fromMessages
([
[
"system"
,
SYSTEM_STRUCT
]
,
[
"human"
,
"{question}"
]
]);
const
catchIntention
=
z
.object
(
{
intention
:
z
.enum
([
'UNKNOWN'
,
'SALES'
,
'GREETING'
,
'CLOSURE'
])
.describe
(
'Categorize the following conversation and decide what the intention is'
)
}
)
.describe
(
'Given the following products, you should structure it in the best way, do not alter or edit anything'
);
const
llmWithToolsCatchIntention
=
openAI
.withStructuredOutput
(catchIntention
,
{
name
:
"CatchIntention"
,
});
export
const
getIntention
=
async
(text
:
string
)
:
Promise
<
string
>
=>
{
try
{
const
{
intention
}
=
await
PROMPT_STRUCT
.pipe
(llmWithToolsCatchIntention)
.invoke
({
question
:
text
,
history
:
await
history
.getHistory
(state)
});
return
Promise
.resolve
(
String
(intention)
.toLocaleLowerCase
());
}
catch
(errorIntention) {
return
Promise
.resolve
(
'unknown'
);
}
};
Copy
Copied!
That way you can validate the intentions of your end customer and set up your own purchase flow as easy as that
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de tutorials_migrate-to-builderbot.txt ---
Migrating from bot-whatsapp to builderbot: A Simple Guide - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
Key Differences
Easy Migration Steps
Code Comparison
Final Considerations
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Migrating from bot-whatsapp to builderbot: A Simple Guide
builderbot is the next evolution of bot-whatsapp, maintaining 99% compatibility while introducing significant improvements. This guide will walk you through the straightforward migration process.
Key Differences
Name Change
: From bot-whatsapp to builderbot
Enhanced Language Support
: Now includes TypeScript in addition to JavaScript
Improved Features
: New functionalities while maintaining familiar concepts
Easy Migration Steps
Update Dependencies
First, install the latest builderbot core:
npm
install
@builderbot/bot@latest
# or
pnpm
add
@builderbot/bot@latest
Copy
Copied!
Install Your Preferred Provider
Choose and install the provider you're using:
baileys
meta
twilio
venom
wppconnect
whatsapp-web
pnpm
install
@builderbot/provider-baileys@latest
Copy
Copied!
Update Imports
Modify your imports to use builderbot:
// Old
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
}
=
require
(
'@bot-whatsapp/bot'
)
// New
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB
}
=
require
(
'@builderbot/bot'
)
Copy
Copied!
Update Provider
Change the provider import and initialization:
// Old
const
WebWhatsappProvider
=
require
(
'@bot-whatsapp/provider/web-whatsapp'
)
// New
const
{
BaileysProvider
}
=
require
(
'@builderbot/bot'
)
// When initializing:
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
// New feature in builderbot
Copy
Copied!
Update Database
Update your database adapter:
// Old
const
MockAdapter
=
require
(
'@bot-whatsapp/database/mock'
)
const
adapterDB
=
new
MockAdapter
()
// New
const
{
MemoryDB
}
=
require
(
'@builderbot/bot'
)
const
adapterDB
=
new
MemoryDB
()
Copy
Copied!
Review and Update Flows
While most of your flows will work as-is, consider using new features like
addAction
for more complex logic:
const
infoFlow
=
addKeyword
(
'info'
)
.addAction
(
async
(ctx
,
{ flowDynamix })
=>
{
await
flowDynamix
(
`Welcome
${
ctx
.name
}
`
)
})
Copy
Copied!
Code Comparison
Here's a side-by-side comparison of a basic bot setup in bot-whatsapp and builderbot:
bot-whatsapp
builderbot
const
{
createBot
,
createProvider
,
createFlow
,
addKeyword
}
=
require
(
'@bot-whatsapp/bot'
)
const
BaileysProvider
=
require
(
'@bot-whatsapp/provider/baileys'
)
const
MockAdapter
=
require
(
'@bot-whatsapp/database/mock'
)
const
flowPrincipal
=
addKeyword
([
'hola'
,
'alo'
])
.addAnswer
([
'Hola, bienvenido a mi tienda'
,
'¿Como puedo ayudarte?'
])
.addAnswer
([
'Tengo:'
,
'Zapatos'
,
'Bolsos'
,
'etc ...'
])
const
main
=
async
()
=>
{
const
adapterDB
=
new
MockAdapter
()
const
adapterFlow
=
createFlow
([flowPrincipal])
const
adapterProvider
=
createProvider
(BaileysProvider)
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Final Considerations
Migration should be relatively straightforward due to high compatibility
Take advantage of new builderbot features, especially if you opt to use TypeScript
Maintain your existing development practices and patterns, as they remain valid
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

--- Contenido de uses-cases.txt ---
Examples - BuilderBot.app Chatbot for Whatsapp, Telegram and more
🚀 ¡Nuevo! builderbot cloud para No-code
¡Pruébalo gratis!
BuilderBot
K
BuilderBot
Contribute
Course
Get started
API
Documentation
Support
Start here
Introduction
Quickstart
Concepts
Examples
How to Update to the Latest Version
My first bot
Conversational history
state
Dynamic Messages
flowDynamic
Send File
Switch to another flow
gotoFlow
Turn off bot a certain user
state
Turn off for everyone
state
Bot Self-Interaction
state
Basics
Functions
Context
Methods
Events
Built-in
Databases
Providers
Meta
Twilio
Baileys
Venom
WPPConnect
Deploy
Resume
Railway
Docker
VPS
Recipes
Queue limit
Modularize
Fast Entries
Idle
Scheduled Reboots
In-Out messages
Reminder
Forward to human
GotoFlow Use
Multiple messages
Tutorials
Migrate from bot-whatsapp
API Rest
Gemini
Langchain
Community Contribute
Documentation
Core
Brand and Logos
Plugins
Telegram
Shopify
Agents
Langchain
Sign in
Examples
Below you will find different examples showing the implementation in different use cases. These examples have been compiled based on the community, feel free to post an example that you like or that you think would be useful for new people.
How to Update to the Latest Version
To ensure you're using the most up-to-date features and bug fixes, it's important to keep your BuilderBot installation current. Follow the steps below to update to the latest version.
To keep your project up to date, make sure to run the command to update the core and the corresponding provider
pnpm
install
@builderbot/bot@latest
pnpm
install
@builderbot/provider-baileys@latest
pnpm
install
@builderbot/provider-wppconnect@latest
pnpm
install
@builderbot/provider-venom@latest
pnpm
install
@builderbot/provider-meta@latest
pnpm
install
@builderbot/provider-twilio@latest
Copy
Copied!
My first bot
The following code represents the quick use of a bot that when you type the word
hi
, greets you with a welcome message and asks you for your name and then returns a funny image
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
welcomeFlow
=
addKeyword
<
BaileysProvider
,
MemoryDB
>([
'hi'
])
.addAnswer
(
'Ey! welcome'
)
.addAnswer
(
'Your name is?'
,
{ capture
:
true
}
,
async
(ctx
,
{ flowDynamic })
=>
{
await
flowDynamic
([
`nice!
${
ctx
.body
}
`
,
'I will send you a funny image'
])
})
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
dataApi
=
await
fetch
(
`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`
)
const
[
imageUrl
]
=
await
dataApi
.json
()
await
flowDynamic
([{body
:
'😜'
,
media
:
imageUrl}])
})
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([welcomeFlow])
const
adapterProvider
=
createProvider
(BaileysProvider)
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
state
Conversational history
Often, we will need to manage conversations and keep the context in a memory called
state
which is volatile and accessible from any function executed in a stream.
const
welcomeFlow
=
addKeyword
([
'hello'
])
.addAnswer
(
"¿What's your name?"
,
{capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
=>
{
await
state
.update
({ name
:
ctx
.body })
await
flowDynamic
(
'Thanks for giving me your name!'
)
}
)
.addAnswer
(
'¿How old are you?'
,
{capture
:
true
}
,
async
(ctx
,
{ flowDynamic
,
state })
=>
{
const
name
=
state
.get
(
'name'
)
await
state
.update
({ age
:
ctx
.body })
await
flowDynamic
(
`Thanks for sharing your age!
${
name
}
`
)
}
)
.addAnswer
(
'Here is your data:'
,
null
,
async
(_
,
{ flowDynamic
,
state })
=>
{
const
myState
=
state
.getMyState
()
await
flowDynamic
(
`Name:
${
myState
.name
}
Age:
${
myState
.age
}
`
)
})
Copy
Copied!
flowDynamic
Dynamic Messages
In other occasions we need to send messages in a dynamic way of data that can be variable, below you can see an example of how you should do it and how you should NOT do it.
❌ Avoid it this, does not work because addAnswer serializes the content at the start of execution.
let
name
=
''
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx)
=>
{
name
=
ctx
.body
})
.addAnswer
(
`Your name is:
${
name
}
`
)
Copy
Copied!
If you want to send a dynamic message use flowDynamic.
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`What is your name?`
,
{ capture
:
true
}
,
async
(ctx
,
{ state })
=>
{
await
state
.update
({ name
:
ctx
.body })
})
.addAction
(
async
(ctx
,
{ state
,
flowDynamic })
=>
{
const
name
=
state
.get
(
'name'
)
await
flowDynamic
(
`Your name is:
${
name
}
`
)
})
Copy
Copied!
Send File
When you want to
send an image, audio
, file or any other file you can do it this way. It is
important
to note that the URL must be
publicly accessible
.
const
flow
=
addKeyword
(
'hello'
)
.addAnswer
(
`Send image from URL`
,
{ media
:
'https://i.imgur.com/0HpzsEm.png'
}
)
.addAnswer
(
`Send video from Local`
,
{ media
:
join
(
process
.cwd
()
,
'assets'
,
'sample.png'
) }
)
.addAnswer
(
`Send video from URL`
,
{ media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
)
.addAnswer
(
`Send file from URL`
,
{ media
:
'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'
}
)
Copy
Copied!
Other ways to use when the route is coming from a dynamic data source
const
flow
=
addKeyword
(
'hello'
)
.addAction
(
async
(_
,
{flowDynamic})
=>
{
// ...db get source...
await
flowDynamic
([
{body
:
'This is an image'
,
media
:
'https://i.imgur.com/0HpzsEm.png'
}
])
await
flowDynamic
([
{body
:
'This is a video'
,
media
:
'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'
}
])
})
Copy
Copied!
If you need to send a file that is stored locally you can do that too. The use of
join
is recommended to ensure correct directory concatenation.
const
flow
=
addKeyword
(
'hello'
)
.addAction
(
async
(_
,
{flowDynamic})
=>
{
const
pathLocal
=
join
(
'assets'
,
'doc.pdf'
)
// pathLocal = c:/doc.pdf
await
flowDynamic
([
{body
:
'This is a video'
,
media
:
pathLocal }
])
})
Copy
Copied!
gotoFlow
Switch to another flow
If you want to divert a conversational flow to another logic flow based on a response input you can do it in this way:
const
flowToA
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option A!'
)
const
flowToB
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option B!'
)
const
flowToC
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
'Here we have Option C!'
)
const
flowDefault
=
addKeyword
(
EVENTS
.
ACTION
)
.addAnswer
(
"We don't have that Option 🤔"
)
const
flow
=
addKeyword
(
'order'
)
.addAnswer
(
[
`Which one is the best option for you?`
,
`Type **A**`
,
`Type **B**`
,
`Type **C**`
,
]
,
{ capture
:
true
}
)
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
const
userAnswer
=
ctx
.body
if
(userAnswer
===
'A'
){
return
gotoFlow
(flowToA)
}
if
(userAnswer
===
'B'
){
return
gotoFlow
(flowToB)
}
if
(userAnswer
===
'C'
){
return
gotoFlow
(flowToC)
}
return
gotoFlow
(flowDefault)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
❌ This does not work, the invocation of the gotoFlow function must necessarily include a return.
//...Previous code...
...
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
gotoFlow
(flowToA)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
This does work
//...Previous code...
...
.addAnswer
(
`Thanks for you answer`
,
async
(ctx
,
{gotoFlow})
=>
{
return
gotoFlow
(flowToA)
})
.addAnswer
(
`this message will not be sent`
)
Copy
Copied!
state
Turn off bot a certain user
Sometimes we will need to turn off the bot for a certain user, so that we can have a conversation with the client without the bot interfering.
const
flow
=
addKeyword
<
BaileysProvider
>(
'magic keyword'
)
.addAction
(
async
(_
,
{ state
,
endFlow })
=>
{
const
botOffForThisUser
=
state
.get
<
boolean
>(
'botOffForThisUser'
)
await
state
.update
({botOffForThisUser
:!
botOffForThisUser})
if
(botOffForThisUser)
return
endFlow
()
})
.addAnswer
(
'Hello!'
)
Copy
Copied!
state
Turn off for everyone
Sometimes we will need to disable the bot for all people, without the need to shut down the server or stop the script.
const
flow
=
addKeyword
<
BaileysProvider
>(
'botoff'
)
.addAction
(
async
(_
,
{ globalState
,
endFlow })
=>
{
const
botOffForEveryOne
=
globalState
.get
<
boolean
>(
'botOffForEveryOne'
)
await
globalState
.update
({botOffForEveryOne
:!
botOffForEveryOne})
if
(botOffForEveryOne)
return
endFlow
()
})
.addAnswer
(
'Hello!'
)
Copy
Copied!
state
Bot Self-Interaction
In certain scenarios, it is necessary for the bot's phone number (host) to be able to interact within logical flows. To achieve this, we have several configurable options:
host:
This is used when you want the bot to be able to respond to messages in the same chat with itself. For example, if the bot's number is 0000, it will be able to send and receive messages to/from 0000.
both:
This option allows both the bot and you (the developer/administrator) to intervene in the chat of a person interacting with the bot.
none:
(default option) Only allows interaction between the user and the bot, without intervention from the host number.
app.ts
import
{ createBot
,
createProvider
,
createFlow
,
addKeyword
,
MemoryDB }
from
'@builderbot/bot'
import
{ BaileysProvider }
from
'@builderbot/provider-baileys'
const
main
=
async
()
=>
{
const
adapterDB
=
new
MemoryDB
()
const
adapterFlow
=
createFlow
([
...
])
const
adapterProvider
=
createProvider
(BaileysProvider
,
{
writeMyself
:
'host'
as
'none'
|
'host'
|
'both'
})
adapterProvider
.initHttpServer
(
3000
)
await
createBot
({
flow
:
adapterFlow
,
provider
:
adapterProvider
,
database
:
adapterDB
,
})
}
main
()
Copy
Copied!
Guides
My first chatbot
Learn how build your first chatbot in few minutes
Read more
Concepts
Understand the essential concepts for building bots
Read more
Add Functions
The key to learning how to write flows is add-functions.
Read more
Plugins
Unlimitate and start implementing the community plugins.
Read more
Resources
Modularize
Learn how to modularise flows so that you can have a more maintainable bot.
Send Message
How to send a message via HTTP to start conversations, you can send multimedia as well.
Dockerizer
A good practice is to dockerise your bots to make them more maintainable and effective.
Events
Learning about events will make us more fluent when creating chatbots.
Was this page helpful?
Yes
No
© Copyright
2024
. All rights reserved.
Follow us on Twitter
Follow us on GitHub
Join our Discord server

